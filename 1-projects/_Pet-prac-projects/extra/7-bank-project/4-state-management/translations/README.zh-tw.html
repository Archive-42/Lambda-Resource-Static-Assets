<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.zh-tw</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="建立銀行網頁應用程式-part-4-狀態控管的概念">建立銀行網頁應用程式 Part 4： 狀態控管的概念</h1>
<h2 id="課前測驗">課前測驗</h2>
<p><a href="https://nice-beach-0fe9e9d0f.azurestaticapps.net/quiz/47?loc=zh_tw">課前測驗</a></p>
<h3 id="大綱">大綱</h3>
<p>隨著網頁應用越來越龐大，追蹤資料流的動向也是一種挑戰。程式取得了何種資料、網頁如何處理它、何時何處被更新上去……這些很容易地導致程式碼凌亂而難以維護。尤其是當你需要在不同頁面上做資料共享時，好比說使用者的資料。<em>狀態控管(state management)</em> 的觀念已經存在於所有程式中，我們也開始需要在開發複雜的網頁應用程式時，注意這個關鍵點。</p>
<p>在這個最終章內，我們會總覽整個程式並重新思考該如何管理程式狀態，讓瀏覽器能在任何時刻做重新整理，在不同的使用者階段維持資料的狀態。</p>
<h3 id="開始之前">開始之前</h3>
<p>你需要先完成<a href="../../3-data/translations/README.zh-tw.md">取得資料</a>的網頁開發章節。你還需要安裝 <a href="https://nodejs.org">Node.js</a> 並於本地端<a href="../../api/translations/README.zh-tw.md">執行伺服器 API</a>以管理使用者資料。</p>
<p>你可以測試伺服器是否運作正常，在終端機中輸入指令：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb1-1" title="1"><span class="ex">curl</span> http://localhost:5000/api</a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co"># -&gt; should return &quot;Bank API v1.0.0&quot; as a result</span></a></code></pre></div>
<hr />
<h2 id="思考狀態控管">思考狀態控管</h2>
<p>在<a href="../../3-data/translations/README.zh-tw.md">前一堂課</a>中，我們介紹了應用程式基本的狀態，全域變數 <code>account</code> 提供登入帳戶的相關銀行資料。然而，現在的專案存在著一些瑕疵。試著在儀表板介面中重新整理。發生了什麼事？</p>
<p>目前我們的程式碼有三個問題：</p>
<ul>
<li>網頁狀態並沒有被儲存，當瀏覽器重新整理時，會被導回登入頁面。</li>
<li>有許多函式會修改網頁狀態。隨著應用程式變大，我們很難去追蹤之後的改變，時刻地去更新相關的網頁狀態。</li>
<li>網頁狀態並不完整，當你<em>登出</em>帳戶時，帳戶資訊仍然顯示在登入頁面上。</li>
</ul>
<p>我們是可以逐一的解決這些問題，但這樣會創造出許多獨立的程式碼，讓應用程式更複雜而難以去管理。或者是我們停下來思考一下我們的策略。</p>
<blockquote>
<p>我們究竟要解決什麼問題？</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/State_management">狀態控管(State management)</a>可以為兩項問題提供良好的解決方案：</p>
<ul>
<li>如何讓應用程式中的資料流容易理解？</li>
<li>如何讓網頁狀態一直與使用者介面，或是相關物件進行同步？</li>
</ul>
<p>一旦你處理好這些問題，其他問題可以被簡化，甚至被一併解決。有許多可能的方法能解決這些問題，但我們使用一種常見的解法：<strong>中心化資料與更新方式</strong>。資料流會呈現下列模式：</p>
<figure>
<img src="../images/data-flow.png" alt="HTML、使用者行為與網頁狀態的架構圖" /><figcaption>HTML、使用者行為與網頁狀態的架構圖</figcaption>
</figure>
<blockquote>
<p>我們不會處理如何讓資料同步觸發頁面的更新，這比較像是關於<a href="https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B">回應式程式設計</a>的更進階知識。當你更深入網頁開發領域時，這是個很好的發展方向。</p>
</blockquote>
<p>✅ 有許多函式庫提供狀態管理的方式，<a href="https://redux.js.org">Redux</a> 就是常見的選擇。閱讀它的概念與運作模式，這是種有效的的學習方式，讓你在大型的網頁開發中預測潛在的風險，並預想解決方案。</p>
<h3 id="課題">課題</h3>
<p>我們會先做一些程式重構。替換掉 <code>account</code> 的定義：</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">let</span> account <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></a></code></pre></div>
<p>變成：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">let</span> state <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="dt">account</span><span class="op">:</span> <span class="kw">null</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="op">};</span></a></code></pre></div>
<p>這個構想是要<em>中心化</em>應用程式資料到一個狀態物件中。目前我們只有 <code>account</code> 在狀態中，但這能提供未來新增新功能的基礎。</p>
<p>我們還需要更新與它相關的函式。在函式 <code>register()</code> 和 <code>login()</code> ，將 <code>account = ...</code> 替換為 <code>state.account = ...</code>。</p>
<p>在函式 <code>updateDashboard()</code> 的上方，加入此行：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">const</span> account <span class="op">=</span> <span class="va">state</span>.<span class="at">account</span><span class="op">;</span></a></code></pre></div>
<p>這個重構並不會帶來任何提升，但這是之後改變上的基礎。 This refactoring by itself did not bring much improvements, but the idea was to lay out the foundation for the next changes.</p>
<h2 id="追蹤資料改變">追蹤資料改變</h2>
<p>現在我們有 <code>state</code> 物件儲存資料了，接下來要來中心化這些更新。目標是能輕易地追蹤任何被觸發的改變。</p>
<p>為了避免改動 <code>state</code> 物件，我們考慮使它<a href="https://zh.wikipedia.org/wiki/%E4%B8%8D%E5%8F%AF%E8%AE%8A%E7%89%A9%E4%BB%B6"><em>不可變</em></a>，意味著它不能被做任何的修改。 這也代表你必須建立新的狀態物件來替換它。藉由這個方式，你就有一套保護措施阻絕潛在非預期<a href="https://zh.wikipedia.org/wiki/%E5%89%AF%E4%BD%9C%E7%94%A8_(%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6)">風險</a>，也開創出應用程式內還原與重做的功能，讓程式偵錯更加的容易。舉例來說，你可以紀錄狀態的改變，儲存狀態的歷史紀錄來了解錯誤的來源。</p>
<p>在 JavaScript 中，你可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze"><code>Object.freeze()</code></a> 來建立不可變物件。若你想在不可變物件上做更動，例外處理(exception)就會發生。</p>
<p>✅ 你知道<em>淺複製(shallow)</em>和<em>深複製(deep)</em>這兩種不可變物件的差別嗎？你可以從<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze#What_is_shallow_freeze">這裡</a>閱讀相關資訊。</p>
<h3 id="課題-1">課題</h3>
<p>我們來建立新的函式 <code>updateState()</code>：</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">function</span> <span class="at">updateState</span>(property<span class="op">,</span> newData) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">  state <span class="op">=</span> <span class="va">Object</span>.<span class="at">freeze</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb5-3" title="3">    ...<span class="at">state</span><span class="op">,</span></a>
<a class="sourceLine" id="cb5-4" title="4">    [property]<span class="op">:</span> newData</a>
<a class="sourceLine" id="cb5-5" title="5">  <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>在這個函式中，我們會建立新的狀態物件，並利用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_syntax#Spread_in_object_literals"><em>展開運算子(<code>...</code>)(Spread Operator)</em></a>複製前一個資料狀態。接著，我們使用<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects#Objects_and_properties">括弧記法(Bracket Notation)</a> <code>[property]</code> 賦予並覆蓋特定的狀態物件。最後，我們為物件上鎖，<code>Object.freeze()</code> 避免任何的改動。目前我們只有 <code>account</code> 資料存在狀態中，利用此方法可以讓你新增任何你想要的資料。</p>
<p>我們會更新 <code>state</code> 初始化設定，確保初始狀態也被上鎖：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">let</span> state <span class="op">=</span> <span class="va">Object</span>.<span class="at">freeze</span>(<span class="op">{</span></a>
<a class="sourceLine" id="cb6-2" title="2">  <span class="dt">account</span><span class="op">:</span> <span class="kw">null</span></a>
<a class="sourceLine" id="cb6-3" title="3"><span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>接著，更新函式 <code>register</code>，將 <code>state.account = result;</code> 替換為：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="at">updateState</span>(<span class="st">&#39;account&#39;</span><span class="op">,</span> result)<span class="op">;</span></a></code></pre></div>
<p>在函式 <code>login</code> 上做一樣的事，將 <code>state.account = data;</code> 替換為：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="at">updateState</span>(<span class="st">&#39;account&#39;</span><span class="op">,</span> data)<span class="op">;</span></a></code></pre></div>
<p>藉由這個機會，我們能解決帳戶資料在<em>登出</em>時，不會被清除的問題。</p>
<p>建立新的函式 <code>logout()</code>：</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">function</span> <span class="at">logout</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="at">updateState</span>(<span class="st">&#39;account&#39;</span><span class="op">,</span> <span class="kw">null</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-3" title="3">  <span class="at">navigate</span>(<span class="st">&#39;/login&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>在 <code>updateDashboard()</code> 中，替換重新導向 <code>return navigate('/login');</code> 為 <code>return logout()</code>。</p>
<p>試著註冊新的帳戶，登入登出以確保功能都運作正常。</p>
<blockquote>
<p>提示：你可以觀察所有的狀態改變，在 <code>updateState()</code> 裡的最下方加入 <code>console.log(state)</code>，開啟瀏覽器開發工具，命令欄就會顯示狀態的紀錄。</p>
</blockquote>
<h2 id="紀錄狀態">紀錄狀態</h2>
<p>多數的網頁應用程式需要儲存資料以確保運作正常。所有重要的資料都會存在資料庫中，並藉由伺服器 API 來存取，就像我們專案中的帳戶資料。但有時候，瀏覽器用戶端的應用程式也需要儲存一些資料，提供更好的使用者體驗與增進負載效能。</p>
<p>當你想在瀏覽器內儲存資料，你必須思考幾項重要的問題：</p>
<ul>
<li><em>這項資料很危險嗎？</em> 你應該要避免在用戶端儲存敏感的資料，例如帳戶密碼。</li>
<li><em>你需要儲存資料多久？</em> 你打算短時間內做存取，還是永久地保存？</li>
</ul>
<p>網頁應用程式中有許多儲存資訊的方法，一切都取決於你想達成的目標。舉例來說，你可以利用網址來儲存搜尋資訊，讓使用者間能共享資訊。若資料需要與伺服器共享，好比說<a href="https://zh.wikipedia.org/wiki/%E8%BA%AB%E4%BB%BD%E9%AA%8C%E8%AF%81">認證</a>資訊，你可以使用 <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Cookies">HTTP cookies</a>。</p>
<p>另一個選擇是使用其中一個廣大的瀏覽器 API 來儲存資料。下列這兩項就特別有趣：</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage"><code>localStorage</code></a>：<a href="https://zh.wikipedia.org/wiki/%E9%94%AE-%E5%80%BC%E5%AD%98%E5%82%A8">Key/Value 儲存法</a>可以保存不同時刻的網頁資料。這些資料不會有期限的限制。</li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/Window/sessionStorage"><code>sessionStorage</code></a>：它的運作模式與 <code>localStorage</code> 相同，只差在資料會在網頁段落結束時被清除，如瀏覽器關閉時。</li>
</ul>
<p>紀錄一下這兩個 API 只能儲存<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String">字串</a>格式。 如果你想儲存更複雜的物件，你需要利用 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON/stringify"><code>JSON.stringify()</code></a> 將資料整理成 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/JSON">JSON</a> 格式。</p>
<p>✅ 如果你想要建立不仰賴伺服器的網頁應用程式，你有辦法在用戶端建立資料庫。<a href="https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API"><code>IndexedDB</code> API</a> 可以應用在更進階的案例上，儲存更大量的資料，當然使用上也相對複雜。</p>
<h3 id="課題-2">課題</h3>
<p>我們想讓使用者在登出之前，保持登入狀態。所以我們使用 <code>localStorage</code> 來儲存帳戶資料。首先，定義一組 key 來紀錄我們的資料內容。</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">const</span> storageKey <span class="op">=</span> <span class="st">&#39;savedAccount&#39;</span><span class="op">;</span></a></code></pre></div>
<p>在函式 <code>updateState()</code> 末端加入此行：</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="va">localStorage</span>.<span class="at">setItem</span>(storageKey<span class="op">,</span> <span class="va">JSON</span>.<span class="at">stringify</span>(<span class="va">state</span>.<span class="at">account</span>))<span class="op">;</span></a></code></pre></div>
<p>藉由此方式，帳戶資料就能保存下來，並隨著之前中心化後的狀態而更新。我們開始從之前的重構獲取效益了 🙂。</p>
<p>當資料被儲存後，我們還需要在程式讀取時載入資料。在 <code>app.js</code> 下方編寫更多的初始化程式，建立新的函式 <code>init</code> 並收入之前的程式碼：</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">function</span> <span class="at">init</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="kw">const</span> savedAccount <span class="op">=</span> <span class="va">localStorage</span>.<span class="at">getItem</span>(storageKey)<span class="op">;</span></a>
<a class="sourceLine" id="cb12-3" title="3">  <span class="cf">if</span> (savedAccount) <span class="op">{</span></a>
<a class="sourceLine" id="cb12-4" title="4">    <span class="at">updateState</span>(<span class="st">&#39;account&#39;</span><span class="op">,</span> <span class="va">JSON</span>.<span class="at">parse</span>(savedAccount))<span class="op">;</span></a>
<a class="sourceLine" id="cb12-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb12-6" title="6"></a>
<a class="sourceLine" id="cb12-7" title="7">  <span class="co">// 之前的初始化程式</span></a>
<a class="sourceLine" id="cb12-8" title="8">  <span class="va">window</span>.<span class="at">onpopstate</span> <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="at">updateRoute</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb12-9" title="9">  <span class="at">updateRoute</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb12-10" title="10"><span class="op">}</span></a>
<a class="sourceLine" id="cb12-11" title="11"></a>
<a class="sourceLine" id="cb12-12" title="12"><span class="at">init</span>()<span class="op">;</span></a></code></pre></div>
<p>我們在此接收了儲存資料，並同步地更新狀態資訊。這必須在更新路由<em>之前</em>完成，否則有些程式碼會在頁面更新時，依據狀態來決定其行為。</p>
<p>當儲存完帳戶資料後，我們也定義了<em>儀表板</em>頁面為我們的預設首頁。若程式沒有找到資料，儀表板頁面也能重新導向回<em>登入</em>頁面。在 <code>updateRoute()</code> 中，替換回傳值 <code>return navigate('/login');</code> 為 <code>return navigate('/dashboard');</code>。</p>
<p>登入應用程式並重新整理頁面。你應該能維持在儀表板那頁。這個改變也解決了我們最初面臨的問題……</p>
<h2 id="重整資料">重整資料</h2>
<p>……但我們可能也產生了新問題。啊呀！</p>
<p>使用 <code>test</code> 帳戶進入儀表板頁面，在終端機內執行下列指令以建立新的交易項目：</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode sh"><code class="sourceCode bash"><a class="sourceLine" id="cb13-1" title="1"><span class="ex">curl</span> --request POST \</a>
<a class="sourceLine" id="cb13-2" title="2">     --header <span class="st">&quot;Content-Type: application/json&quot;</span> \</a>
<a class="sourceLine" id="cb13-3" title="3">     --data <span class="st">&quot;{ </span><span class="dt">\&quot;</span><span class="st">date</span><span class="dt">\&quot;</span><span class="st">: </span><span class="dt">\&quot;</span><span class="st">2020-07-24</span><span class="dt">\&quot;</span><span class="st">, </span><span class="dt">\&quot;</span><span class="st">object</span><span class="dt">\&quot;</span><span class="st">: </span><span class="dt">\&quot;</span><span class="st">Bought book</span><span class="dt">\&quot;</span><span class="st">, </span><span class="dt">\&quot;</span><span class="st">amount</span><span class="dt">\&quot;</span><span class="st">: -20 }&quot;</span> \</a>
<a class="sourceLine" id="cb13-4" title="4">     http://localhost:5000/api/accounts/test/transactions</a></code></pre></div>
<p>試著重新整理瀏覽器內儀表板頁面。發生了什麼事？你有看到新的交易項目嗎？</p>
<p>感謝 <code>localStorage</code> 的幫助，狀態成功的儲存下來，但也代表我們在登出登入之前，不能再改變它的內容了！</p>
<p>一個可能的修復策略是在儀表板載入時，重新載入帳戶資訊以避免資料不同步。</p>
<h3 id="課題-3">課題</h3>
<p>建立新的函式 <code>updateAccountData</code>：</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">async</span> <span class="kw">function</span> <span class="at">updateAccountData</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="kw">const</span> account <span class="op">=</span> <span class="va">state</span>.<span class="at">account</span><span class="op">;</span></a>
<a class="sourceLine" id="cb14-3" title="3">  <span class="cf">if</span> (<span class="op">!</span>account) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-4" title="4">    <span class="cf">return</span> <span class="at">logout</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb14-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb14-6" title="6"></a>
<a class="sourceLine" id="cb14-7" title="7">  <span class="kw">const</span> data <span class="op">=</span> <span class="cf">await</span> <span class="at">getAccount</span>(<span class="va">account</span>.<span class="at">user</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-8" title="8">  <span class="cf">if</span> (<span class="va">data</span>.<span class="at">error</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-9" title="9">    <span class="cf">return</span> <span class="at">logout</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb14-10" title="10">  <span class="op">}</span></a>
<a class="sourceLine" id="cb14-11" title="11"></a>
<a class="sourceLine" id="cb14-12" title="12">  <span class="at">updateState</span>(<span class="st">&#39;account&#39;</span><span class="op">,</span> data)<span class="op">;</span></a>
<a class="sourceLine" id="cb14-13" title="13"><span class="op">}</span></a></code></pre></div>
<p>這個方法能檢查我們是否已經登入，重新從伺服器載入用戶資料。</p>
<p>建立另一個函式 <code>refresh</code>：</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">async</span> <span class="kw">function</span> <span class="at">refresh</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="cf">await</span> <span class="at">updateAccountData</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb15-3" title="3">  <span class="at">updateDashboard</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>這能更新帳戶資料，更新 HTML 中的儀表板頁面。這是在儀表板路由被載入時，我們所需要呼叫的函式。更新路由定義為：</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">const</span> routes <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb16-2" title="2">  <span class="st">&#39;/login&#39;</span><span class="op">:</span> <span class="op">{</span> <span class="dt">templateId</span><span class="op">:</span> <span class="st">&#39;login&#39;</span> <span class="op">},</span></a>
<a class="sourceLine" id="cb16-3" title="3">  <span class="st">&#39;/dashboard&#39;</span><span class="op">:</span> <span class="op">{</span> <span class="dt">templateId</span><span class="op">:</span> <span class="st">&#39;dashboard&#39;</span><span class="op">,</span> <span class="dt">init</span><span class="op">:</span> refresh <span class="op">}</span></a>
<a class="sourceLine" id="cb16-4" title="4"><span class="op">};</span></a></code></pre></div>
<p>試著重新載入儀表板，它現在應該能顯示更新後的帳戶資料。</p>
<hr />
<h2 id="挑戰">🚀 挑戰</h2>
<p>每一次儀表板載入時，我們都會重新載入帳戶資料，你認為我們還需要在用戶端儲存<em>所有的帳戶</em>資料嗎？</p>
<p>試著改變 <code>localStorage</code> 內的儲存內容，只包含我們能運行程式的必要資料。</p>
<h2 id="課後測驗">課後測驗</h2>
<p><a href="https://nice-beach-0fe9e9d0f.azurestaticapps.net/quiz/48?loc=zh_tw">課後測驗</a></p>
<h2 id="作業">作業</h2>
<p><a href="assignment.zh-tw.md">編寫“加入交易明細”視窗</a></p>
<p>這邊有完成之後的結果：</p>
<figure>
<img src="../images/dialog.png" alt="“加入交易明細”視窗的例子截圖" /><figcaption>“加入交易明細”視窗的例子截圖</figcaption>
</figure>
</body>
</html>
