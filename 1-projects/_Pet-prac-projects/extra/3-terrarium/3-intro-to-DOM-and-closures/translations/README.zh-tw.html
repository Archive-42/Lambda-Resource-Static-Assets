<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.zh-tw</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="盆栽盒專案-part-3---dom-元素控制與閉包">盆栽盒專案 Part 3 - DOM 元素控制與閉包</h1>
<p><img src="/sketchnotes/webdev101-js.png" alt="DOM 元素與閉包" /> &gt; 由 <a href="https://twitter.com/girlie_mac">Tomomi Imura</a> 繪製</p>
<h2 id="課前測驗">課前測驗</h2>
<p><a href="https://nice-beach-0fe9e9d0f.azurestaticapps.net/quiz/19?loc=zh_tw">課前測驗</a></p>
<h3 id="大綱">大綱</h3>
<p>操作 DOM (Document Object Model) 是網頁開發的一項關鍵。根據<a href="https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction">MDN 文件</a>， 「Document Object Model (DOM) 元素能根據網頁文件的結構與內容來呈現物件」。藉由使用 JavaScript 框架而非原始的 JavaScript 程式碼來管理 DOM，在網頁上操作 DOM 的挑戰已經不比以前困難了，但這裡我們要自己來管理它們！</p>
<p>此外，這堂課也會介紹有關<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">JavaScript 閉包(Closure)</a>的概念，你可以想像成一個函式被包在另一個函式中，以訪問外面函式範圍中的變數。</p>
<blockquote>
<p>JavaScript 閉包是個廣闊且複雜的主題。本堂課只觸及建立盆栽盒需要的最基礎概念。你能得知一個閉包為：內部函式和外部函式建立一項關係，允許內部函式存取外部函式的變數等作用域。要得知更多關於閉包的原理，請造訪觀看<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">額外的文件</a>。</p>
</blockquote>
<p>我們會使用閉包來操控 DOM。</p>
<p>想像 DOM 就像一棵樹，表現出所有操作網頁的方式。多樣的 APIs (Application Program Interfaces) 提供程式開發者，依照自己使用的程式語言，以存取、編輯、編排等方式管理 DOM 元素。</p>
<figure>
<img src="../images/dom-tree.png" alt="DOM 樹的表達" /><figcaption>DOM 樹的表達</figcaption>
</figure>
<blockquote>
<p>HTML 語法會參考 DOM 的呈現方式。出自 <a href="https://www.researchgate.net/publication/221417012_Profile-Based_Focused_Crawler_for_Social_Media-Sharing_Websites">Olfa Nasraoui</a>。</p>
</blockquote>
<p>在這堂課中，我們會完成我們的盆栽盒專案，建立 JavaScript 來對網頁中的植物進行互動式操作。</p>
<h3 id="開始之前">開始之前</h3>
<p>確保盆栽盒的 HTML 與 CSS 已經編輯完成。這堂課會新增拖曳植物進出盆栽罐的功能。</p>
<h3 id="課題">課題</h3>
<p>在專案資料夾中，新增檔案 <code>script.js</code>。 匯入該檔案在 HTML 檔 <code>&lt;head&gt;</code> 的部分：</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb1-1" title="1">    <span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;./script.js&quot;</span><span class="ot"> defer</span><span class="kw">&gt;&lt;/script&gt;</span></a></code></pre></div>
<h2 id="筆記匯入外部-javascript-檔案到-html-檔案須使用-defer讓-javascript-檔案只有在-html-被完全載入時才被執行你也可以使用-async-的屬性允許-javascript-在解析-html-檔時就被執行這項專案中我們必須確保-html-的元件被完整建立後才允許使用拖曳功能">&gt; 筆記：匯入外部 JavaScript 檔案到 HTML 檔案須使用 <code>defer</code>，讓 JavaScript 檔案只有在 HTML 被完全載入時才被執行。你也可以使用 <code>async</code> 的屬性，允許 JavaScript 在解析 HTML 檔時就被執行。這項專案中，我們必須確保 HTML 的元件被完整建立後才允許使用拖曳功能。</h2>
<h2 id="dom-元素">DOM 元素</h2>
<p>我們要做的第一件事是建立 DOM 下，要被操控的物件的連結。在專案例子中，我們有罐子外的十四株植物等著被拖曳。</p>
<h3 id="課題-1">課題</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb2-1" title="1">dragElement(document.getElementById(&#39;plant1&#39;));</a>
<a class="sourceLine" id="cb2-2" title="2">dragElement(document.getElementById(&#39;plant2&#39;));</a>
<a class="sourceLine" id="cb2-3" title="3">dragElement(document.getElementById(&#39;plant3&#39;));</a>
<a class="sourceLine" id="cb2-4" title="4">dragElement(document.getElementById(&#39;plant4&#39;));</a>
<a class="sourceLine" id="cb2-5" title="5">dragElement(document.getElementById(&#39;plant5&#39;));</a>
<a class="sourceLine" id="cb2-6" title="6">dragElement(document.getElementById(&#39;plant6&#39;));</a>
<a class="sourceLine" id="cb2-7" title="7">dragElement(document.getElementById(&#39;plant7&#39;));</a>
<a class="sourceLine" id="cb2-8" title="8">dragElement(document.getElementById(&#39;plant8&#39;));</a>
<a class="sourceLine" id="cb2-9" title="9">dragElement(document.getElementById(&#39;plant9&#39;));</a>
<a class="sourceLine" id="cb2-10" title="10">dragElement(document.getElementById(&#39;plant10&#39;));</a>
<a class="sourceLine" id="cb2-11" title="11">dragElement(document.getElementById(&#39;plant11&#39;));</a>
<a class="sourceLine" id="cb2-12" title="12">dragElement(document.getElementById(&#39;plant12&#39;));</a>
<a class="sourceLine" id="cb2-13" title="13">dragElement(document.getElementById(&#39;plant13&#39;));</a>
<a class="sourceLine" id="cb2-14" title="14">dragElement(document.getElementById(&#39;plant14&#39;));</a></code></pre></div>
<p>發生了什麼事？你正以 DOM 搜尋網頁檔內的物件，藉由 Id 作為依據來搜尋。回想第一堂 HTML 課中，我們可每一株植物一個專屬的 Id (<code>id="plant1"</code>)，現在你就可以使用它。在辨別完每一株植物物件後，傳遞給待編輯的函式 <code>dragElement</code>，讓 HTML 物件可以被拖曳。</p>
<p>✅ 為什麼我們要以 Id 作為物件的參考？為什麼不以 CSS 的 class 作為參考？請參考以前的 CSS 課程回答此問題。</p>
<hr />
<h2 id="閉包closure">閉包(Closure)</h2>
<p>現在，你已經準備好要建立 dragElement 閉包，建立包在外部函式內的內部函式組，在我們的例子中，會用上三個函式。</p>
<p>閉包在一或多個以上函式要存取外部函式時非常好用。看看下面的例子：</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">function</span> <span class="at">displayCandy</span>()<span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">let</span> candy <span class="op">=</span> [<span class="st">&#39;jellybeans&#39;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">function</span> <span class="at">addCandy</span>(candyType) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-4" title="4">        <span class="va">candy</span>.<span class="at">push</span>(candyType)</a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="op">}</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="at">addCandy</span>(<span class="st">&#39;gumdrops&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="at">displayCandy</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="va">console</span>.<span class="at">log</span>(candy)</a></code></pre></div>
<p>這項例子中，函式 displayCandy 包住另一個函式 addCandy，新增新的糖果樣式到已存在的矩陣當中。當執行這段程式時，矩陣 <code>candy</code> 會被認作是未定義，因為它是函式的本地變數。</p>
<p>✅ 你能讓矩陣 <code>candy</code> 被存取嗎？試著將它移到閉包外面。這時，矩陣會變成全域變數，取消閉包內的存取限制。</p>
<h3 id="課題-2">課題</h3>
<p>在檔案 <code>script.js</code> 的元素宣告下方，新增函式：</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">function</span> <span class="at">dragElement</span>(terrariumElement) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="co">//set 4 positions for positioning on the screen</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">let</span> pos1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb4-4" title="4">        pos2 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb4-5" title="5">        pos3 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb4-6" title="6">        pos4 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="va">terrariumElement</span>.<span class="at">onpointerdown</span> <span class="op">=</span> pointerDrag<span class="op">;</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="op">}</span></a></code></pre></div>
<p><code>dragElement</code> 藉由程式定義的參數取得 <code>terrariumElement</code> 物件。之後，設定一些位置 <code>0</code> 的變數給函式內的物件使用。它們是本地變數，給每一個進到拖曳函式內的物件操控。盆栽盒會被這些拖曳物件填充，我們的網頁應用必須要持續追蹤這些物件的位置。</p>
<p>此外，進到函式的 terrariumElement 也被新增了 <code>pointerdown</code> 事件，它是管理 DOM 的其中一項<a href="https://developer.mozilla.org/en-US/docs/Web/API">網頁 APIs</a>。當按鈕按下時，或是在我們案例中，一個拖曳物件被點擊時，<code>onpointerdown</code> 事件就會被觸發。這個事件處理器(event handler)皆運作在<a href="https://caniuse.com/?search=onpointerdown">網頁與行動瀏覽器</a>上，只有少部分的例外。</p>
<p>✅ <a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalEventHandlers/onclick">事件處理器 <code>onclick</code></a>支援更多的瀏覽器。為什麼我們不在這邊使用它？ 想想看我們在這此建立的視窗互動類型。</p>
<hr />
<h2 id="函式-pointerdrag">函式 pointerDrag</h2>
<p>terrariumElement 已經準備好被拖曳了。當觸發 <code>onpointerdown</code> 事件時，函式 pointerDrag 會參與其中。新增這項函式在程式碼 <code>terrariumElement.onpointerdown = pointerDrag;</code> 下方：</p>
<h3 id="課題-3">課題</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">function</span> <span class="at">pointerDrag</span>(e) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="va">e</span>.<span class="at">preventDefault</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(e)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4">    pos3 <span class="op">=</span> <span class="va">e</span>.<span class="at">clientX</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-5" title="5">    pos4 <span class="op">=</span> <span class="va">e</span>.<span class="at">clientY</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>許多事情會發生。首先，你使用 <code>e.preventDefault();</code> 取消掉 pointerdown 原先的預設事件。這樣你可以操作更多的介面行為。</p>
<blockquote>
<p>回到你建立的程式碼中，試著刪除 <code>e.preventDefault()</code> 並執行看看，發生了什麼事？</p>
</blockquote>
<p>第二，用瀏覽器打開 <code>index.html</code> 並調查我們的介面。當你點擊植物時，你可以發現 ‘e’ 事件被觸發了。專研一下，一個 pointerdown 事件會產生多少資訊！</p>
<p>接下來，紀錄本地變數 <code>pos3</code> 和 <code>pos4</code> 被設定為 e.clientX 和 e.clientY。你可以在觀察面板中，會發現 <code>e</code> 的數值。這項數值取得按下植物瞬間的 x 與 y 座標資訊。為了全面的控制植物行為，在拖曳植物時，我們會持續更新座標資訊。</p>
<p>✅ 將整個網頁應用建立在一個大閉包下，會讓程式碼變得比較清楚嗎？如果沒有，你有其他方法管理這十四株可拖曳的植物嗎？</p>
<p>增加初始化函式，在程式碼 <code>pos4 = e.clientY</code> 下方加上下列兩行事件處理：</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb6-1" title="1">document.onpointermove = elementDrag;</a>
<a class="sourceLine" id="cb6-2" title="2">document.onpointerup = stopElementDrag;</a></code></pre></div>
<p>現在，在游標拖曳時，你的植物能跟著你的游標走，而在你取消點擊時停下來。<code>onpointermove</code> 和 <code>onpointerup</code> 也是 <code>onpointerdown</code> 類型相同的 API。然而，現在介面會出現錯誤訊息，因為我們還沒建立函式 <code>elementDrag</code> 與 <code>stopElementDrag</code>。</p>
<h2 id="函式-elementdrag-與-stopelementdrag">函式 elementDrag 與 stopElementDrag</h2>
<p>新增兩條內部函式在閉包中，它們會處理拖曳植物與停止拖曳的事件。你希望你可以拖曳任何一株植物且放在螢幕上的任一地方。介面並沒有強制你盆栽盒的配置格式，你可以自由地增加、移除與移動盆栽罐內的植物。</p>
<h3 id="課題-4">課題</h3>
<p>新增函式 <code>elementDrag</code> 在函式閉包 <code>pointerDrag</code> 宣告列的正下方：</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">function</span> <span class="at">elementDrag</span>(e) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-2" title="2">    pos1 <span class="op">=</span> pos3 <span class="op">-</span> <span class="va">e</span>.<span class="at">clientX</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-3" title="3">    pos2 <span class="op">=</span> pos4 <span class="op">-</span> <span class="va">e</span>.<span class="at">clientY</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" title="4">    pos3 <span class="op">=</span> <span class="va">e</span>.<span class="at">clientX</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-5" title="5">    pos4 <span class="op">=</span> <span class="va">e</span>.<span class="at">clientY</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="va">console</span>.<span class="at">log</span>(pos1<span class="op">,</span> pos2<span class="op">,</span> pos3<span class="op">,</span> pos4)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="va">terrariumElement</span>.<span class="va">style</span>.<span class="at">top</span> <span class="op">=</span> <span class="va">terrariumElement</span>.<span class="at">offsetTop</span> <span class="op">-</span> pos2 <span class="op">+</span> <span class="st">&#39;px&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="va">terrariumElement</span>.<span class="va">style</span>.<span class="at">left</span> <span class="op">=</span> <span class="va">terrariumElement</span>.<span class="at">offsetLeft</span> <span class="op">-</span> pos1 <span class="op">+</span> <span class="st">&#39;px&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>在這條函式之前，你編輯了四個本地變數位置的初始值在外部函式中。這邊又做了什麼事？</p>
<p>當你拖曳物件時，你更新數值 <code>pos1</code> 為 <code>pos3</code> 減去現在的 <code>e.clientX</code>，而 <code>pos3</code> 在之前被初始化為為 <code>e.clientX</code>。同樣的行為套用在 <code>pos2</code>上。之後，你更新 <code>pos3</code> 與 <code>pos4</code> 到新的 XY 座標點位置。你能在 console 下看到數值在拖曳下更新的情況。我們也更新植物的 CSS 造型中的定位點為 <code>pos1</code> 與 <code>pos2</code>，比較植物左上方座標點與新座標點的關係。</p>
<blockquote>
<p><code>offsetTop</code> 和 <code>offsetLeft</code> 是 CSS 的屬性，決定物件與它父關係物件的定位關係。父關係物件可以是任何元素，只要它的定位屬性不為 <code>static</code>。</p>
</blockquote>
<p>這些座標點的計算式讓你成功校整了植物與盆栽盒之間的行為。</p>
<h3 id="課題-5">課題</h3>
<p>最後的課題是在介面上新增 <code>stopElementDrag</code> 函式，我們將它加在函式閉包 <code>elementDrag</code> 的正下方：</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">function</span> <span class="at">stopElementDrag</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="va">document</span>.<span class="at">onpointerup</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="va">document</span>.<span class="at">onpointermove</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>這條小函式重制 <code>onpointerup</code> 與 <code>onpointermove</code> 事件，這樣你可以重新開始該植物的拖曳事件，或是拖曳新的植物。</p>
<p>✅ 如果不將這些事件設為空值時，會發生什麼事？</p>
<p>我們終於完成了這項專案！</p>
<p>🥇 恭喜你！你建立了一個漂亮的盆栽盒。<img src="../images/terrarium-final.png" alt="盆栽盒成果圖" /></p>
<hr />
<h2 id="挑戰">🚀 挑戰</h2>
<p>新增新的事件處理器到你的閉包中，讓你能對植物做更多的事情。舉例來說，雙擊植物讓它排列到最上層。發揮你的創意吧！</p>
<h2 id="課後測驗">課後測驗</h2>
<p><a href="https://nice-beach-0fe9e9d0f.azurestaticapps.net/quiz/20?loc=zh_tw">課後測驗</a></p>
<h2 id="複習與自學">複習與自學</h2>
<p>在螢幕上拖曳物件看似簡單，但依照不同的目的與實現方法會遭遇到不同的問題。事實上，這邊有一份關於你可以嘗試的<a href="https://developer.mozilla.org/en-US/docs/Web/API/HTML_Drag_and_Drop_API">拖曳 API</a>。我們沒在專案中使用是為了建立不一樣的實現方法，試著使用這些 API 到專案中，看看你能完成什麼。</p>
<p>在<a href="https://www.w3.org/TR/pointerevents1/">W3C 文件</a> 和 <a href="https://developer.mozilla.org/en-US/docs/Web/API/Pointer_events">MDN 網頁文件</a>上取得更多關於 pointer 的事件。</p>
<p>記得習慣性用<a href="https://caniuse.com/">CanIUse.com</a>檢查網頁的瀏覽器兼容性。</p>
<h2 id="作業">作業</h2>
<p><a href="assignment.zh-tw.md">用 DOM 做更多事</a></p>
</body>
</html>
