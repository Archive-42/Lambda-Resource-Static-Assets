<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2018-04-17" />
  <title>New in Chrome 66</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">New in Chrome 66</h1>
<p class="date">2018-04-17</p>
</header>
<p>{% YouTube id=‘hsfueop_Hb8’ %}</p>
<ul>
<li>CSS manipulation becomes easier with the new <a href="#cssom">CSS Typed Model Object</a>.</li>
<li>Access to the <a href="#async-clipboard">clipboard</a> is now asynchronous.</li>
<li>There’s a new <a href="#css-paint-api">rendering context</a> for canvas elements.</li>
</ul>
<p>And there’s <a href="#more">plenty more</a>!</p>
<p>I’m Pete LePage. Let’s dive in and see what’s new for developers in Chrome 66!</p>
<p>Want the full list of changes? Check out the <a href="https://chromium.googlesource.com/chromium/src/+log/65.0.3325.146..66.0.3359.116">Chromium source repository change list</a>.</p>
<h2 id="css-typed-object-model-cssom">CSS Typed Object Model {: #cssom }</h2>
<p>If you’ve ever updated a CSS property via JavaScript, you’ve used the CSS object model. But it returns everything as a string.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="va">el</span>.<span class="va">style</span>.<span class="at">opacity</span> <span class="op">=</span> <span class="fl">0.3</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="va">console</span>.<span class="at">log</span>(<span class="kw">typeof</span> <span class="va">el</span>.<span class="va">style</span>.<span class="at">opacity</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="op">&gt;</span> <span class="st">&#39;string&#39;</span> <span class="co">// A string!?</span></a></code></pre></div>
<p>To animate the <code>opacity</code> property, I’d have to cast the string to a number, then increment the value and apply my changes. Not exactly ideal.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">function</span> <span class="at">step</span>(timestamp) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="kw">const</span> currentOpacity <span class="op">=</span> <span class="at">parseFloat</span>(<span class="va">el</span>.<span class="va">style</span>.<span class="at">opacity</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-3" title="3">  <span class="kw">const</span> newOpacity <span class="op">=</span> currentOpacity <span class="op">+</span> <span class="fl">0.01</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="va">element</span>.<span class="va">style</span>.<span class="at">opacity</span> <span class="op">=</span> newOpacity<span class="op">;</span></a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="cf">if</span> (newOpacity <span class="op">&lt;=</span> <span class="dv">1</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="va">window</span>.<span class="at">requestAnimationFrame</span>(step)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-7" title="7">  <span class="op">}</span></a>
<a class="sourceLine" id="cb2-8" title="8"><span class="op">}</span></a></code></pre></div>
<p>With the new CSS Typed Object Model, CSS values are exposed as typed JavaScript objects, eliminating a lot of the type manipulation, and providing a more sensible way of working with CSS.</p>
<p>Instead of using <code>element.style</code>, you access styles through the <code>.attributeStyleMap</code> property or <code>.styleMap</code>. They return a map-like object that makes it easy to read or update.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="va">el</span>.<span class="va">attributeStyleMap</span>.<span class="at">set</span>(<span class="st">&#39;opacity&#39;</span><span class="op">,</span> <span class="fl">0.3</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">const</span> oType <span class="op">=</span> <span class="kw">typeof</span> <span class="va">el</span>.<span class="va">attributeStyleMap</span>.<span class="at">get</span>(<span class="st">&#39;opacity&#39;</span>).<span class="at">value</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="va">console</span>.<span class="at">log</span>(oType)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-4" title="4"><span class="op">&gt;</span> <span class="st">&#39;number&#39;</span> <span class="co">// Yay!</span></a></code></pre></div>
<p>Compared to the old CSS Object Model, early benchmarks show about a 30% improvement in operations per second - something that’s especially important for JavaScript animations.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="va">el</span>.<span class="va">attributeStyleMap</span>.<span class="at">set</span>(<span class="st">&#39;opacity&#39;</span><span class="op">,</span> <span class="fl">0.3</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="va">el</span>.<span class="va">attributeStyleMap</span>.<span class="at">has</span>(<span class="st">&#39;opacity&#39;</span>)<span class="op">;</span> <span class="co">// true</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="va">el</span>.<span class="va">attributeStyleMap</span>.<span class="at">delete</span>(<span class="st">&#39;opacity&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="va">el</span>.<span class="va">attributeStyleMap</span>.<span class="at">clear</span>()<span class="op">;</span> <span class="co">// remove all styles</span></a></code></pre></div>
<p>It also helps to eliminate bugs caused by forgetting to cast the value from a string to a number, and it automatically handles rounding and clamping of values. Plus, there’s some pretty neat new methods for dealing with unit conversions, arithmetic and equality.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="va">el</span>.<span class="va">style</span>.<span class="at">opacity</span> <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">const</span> opacity <span class="op">=</span> <span class="va">el</span>.<span class="at">computedStyleMap</span>().<span class="at">get</span>(<span class="st">&#39;opacity&#39;</span>).<span class="at">value</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="va">console</span>.<span class="at">log</span>(opacity)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4"><span class="op">&gt;</span> <span class="dv">1</span></a></code></pre></div>
<p>Eric has a great post with several demos and examples in his <a href="https://developers.google.com/web/updates/2018/03/cssom">explainer</a>.</p>
<h2 id="async-clipboard-api-async-clipboard">Async Clipboard API {: #async-clipboard }</h2>
<div class="sourceCode" id="cb6"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">const</span> successful <span class="op">=</span> <span class="va">document</span>.<span class="at">execCommand</span>(<span class="st">&#39;copy&#39;</span>)<span class="op">;</span></a></code></pre></div>
<p>Synchronous copy &amp; paste using <code>document.execCommand</code> can be OK for small bits of text, but for anything else, there’s a good chance it’s synchronous nature will block the page, causing a poor experience for the user. And the permission model between browsers is inconsistent.</p>
<p>The new Async Clipboard API is a replacement that works asynchronously, and integrates with the permission API to provide a better experience for users.</p>
<p>Text can be copied to the clipboard by calling <code>writeText()</code>.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="va">navigator</span>.<span class="va">clipboard</span>.<span class="at">writeText</span>(<span class="st">&#39;Copy me!&#39;</span>)</a>
<a class="sourceLine" id="cb7-2" title="2">  .<span class="at">then</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Text is on the clipboard.&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" title="4">  <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Since this API is asynchronous, the <code>writeText()</code> function returns a Promise that will be resolved or rejected depending on whether the text we passed is copied successfully.</p>
<p>Similarly, text can be read from the clipboard by calling <code>getText()</code> and waiting for the returned Promise to resolve with the text.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="va">navigator</span>.<span class="va">clipboard</span>.<span class="at">getText</span>()</a>
<a class="sourceLine" id="cb8-2" title="2">  .<span class="at">then</span>((text) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Clipboard: &#39;</span><span class="op">,</span> text)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" title="4">  <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<p>Check out Jason’s post and demos in the <a href="https://developers.google.com/web/updates/2018/03/clipboardapi">explainer</a>. He’s also got examples that use <code>async</code> functions.</p>
<h2 id="new-canvas-context-bitmaprenderer-css-paint-api">New Canvas Context <code>BitmapRenderer</code> {: #css-paint-api }</h2>
<p>The <code>canvas</code> element lets you manipulate graphics at the pixel level, you can draw graphs, manipulate photos, or even do real time video processing. But, unless you’re starting with a blank <code>canvas</code>, you need a way to render an image on the <code>canvas</code>.</p>
<p>Historically, that’s meant creating an <code>image</code> tag, then rendering it’s contents on to the <code>canvas</code>. Unfortunately that means the browser needs to store multiple copies of the image in memory.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">const</span> context <span class="op">=</span> <span class="va">el</span>.<span class="at">getContext</span>(<span class="st">&#39;2d&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-2" title="2"><span class="kw">const</span> img <span class="op">=</span> <span class="kw">new</span> <span class="at">Image</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="va">img</span>.<span class="at">onload</span> <span class="op">=</span> <span class="kw">function</span> () <span class="op">{</span></a>
<a class="sourceLine" id="cb9-4" title="4">  <span class="va">context</span>.<span class="at">drawImage</span>(img<span class="op">,</span> <span class="dv">0</span><span class="op">,</span> <span class="dv">0</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb9-5" title="5"><span class="op">}</span></a>
<a class="sourceLine" id="cb9-6" title="6"><span class="va">img</span>.<span class="at">src</span> <span class="op">=</span> <span class="st">&#39;llama.png&#39;</span><span class="op">;</span></a></code></pre></div>
<p>Starting in Chrome 66, there’s a new asynchronous rendering context that’s streamlined the display of <code>ImageBitmap</code> objects. They now render more efficiently and with less jank by working asynchronously and avoiding memory duplication.</p>
<p>To use it:</p>
<ol type="1">
<li>Call <code>createImageBitmap</code> and hand it an image blob, to create the image.</li>
<li>Grab the <code>bitmaprenderer</code> context from the <code>canvas</code>.</li>
<li>Then transfer the image in.</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">const</span> image <span class="op">=</span> <span class="cf">await</span> <span class="at">createImageBitmap</span>(imageBlob)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-2" title="2"><span class="kw">const</span> context <span class="op">=</span> <span class="va">el</span>.<span class="at">getContext</span>(<span class="st">&#39;bitmaprenderer&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="va">context</span>.<span class="at">transferFromImageBitmap</span>(image)<span class="op">;</span></a></code></pre></div>
<p>Done, I’ve rendered the image!</p>
<h2 id="audioworklet-audio-worklet">AudioWorklet {: #audio-worklet }</h2>
<p>Worklets are in! PaintWorklet shipped in Chrome 65, and now we’re enabling <a href="https://developers.google.com/web/updates/2017/12/audio-worklet">AudioWorklet</a> by default in Chrome 66. This new type of Worklet can be used to process audio in the dedicated audio thread, replacing the legacy ScriptProcessorNode which ran on the main thread. Each AudioWorklet runs in its own global scope, reducing latency and increasing throughput stability.</p>
<p>There are some interesting examples of AudioWorklet over on <a href="https://googlechromelabs.github.io/web-audio-samples/audio-worklet/">Google Chrome Labs</a>.</p>
<h2 id="and-more-more">And more! {: #more }</h2>
<p>These are just a few of the changes in Chrome 66 for developers, of course, there’s plenty more.</p>
<ul>
<li><code>TextArea</code> and <code>Select</code> now support the <code>autocomplete</code> attribute.</li>
<li>Setting <code>autocapitalize</code> on a <code>form</code> element will apply to any child form fields, improving compatibility with Safari’s implementation of <code>autocapitalize</code>.</li>
<li><code>trimStart()</code> and <code>trimEnd()</code> are now available as the standards-based way of trimming whitespace from strings.</li>
</ul>
<p>Be sure to check out <a href="/blog/new-in-devtools-66">New in Chrome DevTools</a>, to learn what’s new in for DevTools in Chrome 66. And, if you’re interested in Progressive Web Apps, check out the new <a href="https://www.youtube.com/playlist?list=PLNYkxOF6rcICnIOm4cfylT0-cEfytBtYt">PWA Roadshow video series</a>. Then, click the <a href="https://goo.gl/6FP1a5">subscribe</a> button on our <a href="https://www.youtube.com/user/ChromeDevelopers/">YouTube channel</a>, and you’ll get an email notification whenever we launch a new video.</p>
<p>I’m Pete LePage, and as soon as Chrome 67 is released, I’ll be right here to tell you – what’s new in Chrome!</p>
</body>
</html>
