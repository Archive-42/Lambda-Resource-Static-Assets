<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2020-12-10" />
  <title>Debugging WebAssembly with modern tools</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Debugging WebAssembly with modern tools</h1>
<p class="date">2020-12-10</p>
</header>
<p>{% YouTube id=‘VBMHswhun-s’ %}</p>
<h2 id="the-road-so-far-past">The road so far {: #past }</h2>
<p>A year ago, Chrome <a href="/blog/webassembly-debug">announced initial support</a> for native WebAssembly debugging in Chrome DevTools.</p>
<p>We demonstrated basic stepping support and talked about opportunities usage of <a href="http://dwarfstd.org/">DWARF</a> information instead of source maps opens for us in the future:</p>
<ul>
<li>Resolving variable names</li>
<li>Pretty-printing types</li>
<li>Evaluating expressions in source languages</li>
<li>…and much more!</li>
</ul>
<p>Today, we’re excited to showcase the promised features come into life and the progress Emscripten and Chrome DevTools teams have made over this year, in particular, for C and C++ apps.</p>
<p>Before we start, please keep in mind that this is still a beta version of the new experience, you need to use the latest version of all tools at your own risk, and if you run into any issues, please report them to <a href="https://bugs.chromium.org/p/chromium/issues/entry?template=DevTools+issue">https://bugs.chromium.org/p/chromium/issues/entry?template=DevTools+issue</a>.</p>
<p>Let’s start with the same simple C example as the last time:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode c"><code class="sourceCode c"><a class="sourceLine" id="cb1-1" title="1"><span class="pp">#include </span><span class="im">&lt;stdlib.h&gt;</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="dt">void</span> assert_less(<span class="dt">int</span> x, <span class="dt">int</span> y) {</a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="cf">if</span> (x &gt;= y) {</a>
<a class="sourceLine" id="cb1-5" title="5">    abort();</a>
<a class="sourceLine" id="cb1-6" title="6">  }</a>
<a class="sourceLine" id="cb1-7" title="7">}</a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb1-10" title="10">  assert_less(<span class="dv">10</span>, <span class="dv">20</span>);</a>
<a class="sourceLine" id="cb1-11" title="11">  assert_less(<span class="dv">30</span>, <span class="dv">20</span>);</a>
<a class="sourceLine" id="cb1-12" title="12">}</a></code></pre></div>
<p>To compile it, we use <a href="https://github.com/emscripten-core/emsdk#downloads--how-do-i-get-the-latest-emscripten-build">latest Emscripten</a> and pass a <code>-g</code> flag, just like in the original post, to include debug information:</p>
<pre class="devsite-terminal devsite-click-to-copy">
emcc -g temp.c -o temp.html
</pre>
<p>Now we can serve the generated page from a localhost HTTP server (for example, with <a href="https://www.npmjs.com/package/serve">serve</a>), and open it in the latest <a href="https://www.google.com/chrome/canary/">Chrome Canary</a>.</p>
<p>This time we’ll also need a helper extension that integrates with Chrome DevTools and helps it make sense of all the debugging information encoded in the WebAssembly file. Please install it by going to this link: <a href="https://goo.gle/wasm-debugging-extension">goo.gle/wasm-debugging-extension</a></p>
<p>You’ll also want to enable WebAssembly debugging in the DevTools <strong>Experiments</strong>. Open Chrome DevTools, click the gear (<strong>⚙</strong>) icon in the top right corner of DevTools pane, go to the <strong>Experiments</strong> panel and tick <strong>WebAssembly Debugging: Enable DWARF support</strong>.</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/46kV95N1TrBgVm4RmcdG.png”, alt=“Experiments pane of the DevTools settings”, width=“800”, height=“325” %}</p>
<p>When you close the <strong>Settings</strong>, DevTools will suggest to reload itself to apply settings, so let’s do just that. That’s it for the one-off setup.</p>
<p>Now we can go back to the <strong>Sources</strong> panel, enable <strong>Pause on exceptions</strong> (⏸ icon), then check <strong>Pause on caught exceptions</strong> and reload the page. You should see the DevTools paused on an exception:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/BLvpLwEA0szeMTxCfApF.png”, alt=“Screenshot of the Sources panel showing how to enable ‘Pause on caugh exceptions’”, width=“800”, height=“354” %}</p>
<p>By default, it stops on an Emscripten-generated glue code, but on the right you can see a <strong>Call Stack</strong> view representing the stacktrace of the error, and can navigate to the original C line that invoked <code>abort</code>:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/v43lGRgH5K1BAxOT8DXq.png”, alt=“DevTools paused in the <code>assert_less</code> function and showing values of <code>x</code> and <code>y</code> in the Scope view”, width=“800”, height=“354” %}</p>
<p>Now, if you look in the <strong>Scope</strong> view, you can see the original names and values of variables in the C/C++ code, and no longer have to figure out what mangled names like <code>$localN</code> mean and how they relate to the source code you’ve written.</p>
<p>This applies not only to primitive values like integers, but to compound types like structures, classes, arrays, etc., too!</p>
<h2 id="rich-type-support-rich-types">Rich type support {: #rich-types }</h2>
<p>Let’s take a look at a more complicated example to show those. This time, we’ll draw a <a href="https://en.wikipedia.org/wiki/Mandelbrot_set">Mandelbrot fractal</a> with the following C++ code:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb2-1" title="1"><span class="pp">#include </span><span class="im">&lt;SDL2/SDL.h&gt;</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="pp">#include </span><span class="im">&lt;complex&gt;</span></a>
<a class="sourceLine" id="cb2-3" title="3"></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="dt">int</span> main() {</a>
<a class="sourceLine" id="cb2-5" title="5">  <span class="co">// Init SDL.</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="dt">int</span> width = <span class="dv">600</span>, height = <span class="dv">600</span>;</a>
<a class="sourceLine" id="cb2-7" title="7">  SDL_Init(SDL_INIT_VIDEO);</a>
<a class="sourceLine" id="cb2-8" title="8">  SDL_Window* window;</a>
<a class="sourceLine" id="cb2-9" title="9">  SDL_Renderer* renderer;</a>
<a class="sourceLine" id="cb2-10" title="10">  SDL_CreateWindowAndRenderer(width, height, SDL_WINDOW_OPENGL, &amp;window,</a>
<a class="sourceLine" id="cb2-11" title="11">                              &amp;renderer);</a>
<a class="sourceLine" id="cb2-12" title="12"></a>
<a class="sourceLine" id="cb2-13" title="13">  <span class="co">// Generate a palette with random colors.</span></a>
<a class="sourceLine" id="cb2-14" title="14">  <span class="kw">enum</span> { MAX_ITER_COUNT = <span class="dv">256</span> };</a>
<a class="sourceLine" id="cb2-15" title="15">  SDL_Color palette[MAX_ITER_COUNT];</a>
<a class="sourceLine" id="cb2-16" title="16">  srand(time(<span class="dv">0</span>));</a>
<a class="sourceLine" id="cb2-17" title="17">  <span class="cf">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; MAX_ITER_COUNT; ++i) {</a>
<a class="sourceLine" id="cb2-18" title="18">    palette[i] = {</a>
<a class="sourceLine" id="cb2-19" title="19">        .r = (<span class="dt">uint8_t</span>)rand(),</a>
<a class="sourceLine" id="cb2-20" title="20">        .g = (<span class="dt">uint8_t</span>)rand(),</a>
<a class="sourceLine" id="cb2-21" title="21">        .b = (<span class="dt">uint8_t</span>)rand(),</a>
<a class="sourceLine" id="cb2-22" title="22">        .a = <span class="dv">255</span>,</a>
<a class="sourceLine" id="cb2-23" title="23">    };</a>
<a class="sourceLine" id="cb2-24" title="24">  }</a>
<a class="sourceLine" id="cb2-25" title="25"></a>
<a class="sourceLine" id="cb2-26" title="26">  <span class="co">// Calculate and draw the Mandelbrot set.</span></a>
<a class="sourceLine" id="cb2-27" title="27">  <span class="bu">std::</span>complex&lt;<span class="dt">double</span>&gt; center(<span class="fl">0.5</span>, <span class="fl">0.5</span>);</a>
<a class="sourceLine" id="cb2-28" title="28">  <span class="dt">double</span> scale = <span class="fl">4.0</span>;</a>
<a class="sourceLine" id="cb2-29" title="29">  <span class="cf">for</span> (<span class="dt">int</span> y = <span class="dv">0</span>; y &lt; height; y++) {</a>
<a class="sourceLine" id="cb2-30" title="30">    <span class="cf">for</span> (<span class="dt">int</span> x = <span class="dv">0</span>; x &lt; width; x++) {</a>
<a class="sourceLine" id="cb2-31" title="31">      <span class="bu">std::</span>complex&lt;<span class="dt">double</span>&gt; point((<span class="dt">double</span>)x / width, (<span class="dt">double</span>)y / height);</a>
<a class="sourceLine" id="cb2-32" title="32">      <span class="bu">std::</span>complex&lt;<span class="dt">double</span>&gt; c = (point - center) * scale;</a>
<a class="sourceLine" id="cb2-33" title="33">      <span class="bu">std::</span>complex&lt;<span class="dt">double</span>&gt; z(<span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb2-34" title="34">      <span class="dt">int</span> i = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb2-35" title="35">      <span class="cf">for</span> (; i &lt; MAX_ITER_COUNT - <span class="dv">1</span>; i++) {</a>
<a class="sourceLine" id="cb2-36" title="36">        z = z * z + c;</a>
<a class="sourceLine" id="cb2-37" title="37">        <span class="cf">if</span> (abs(z) &gt; <span class="fl">2.0</span>)</a>
<a class="sourceLine" id="cb2-38" title="38">          <span class="cf">break</span>;</a>
<a class="sourceLine" id="cb2-39" title="39">      }</a>
<a class="sourceLine" id="cb2-40" title="40">      SDL_Color color = palette[i];</a>
<a class="sourceLine" id="cb2-41" title="41">      SDL_SetRenderDrawColor(renderer, color.r, color.g, color.b, color.a);</a>
<a class="sourceLine" id="cb2-42" title="42">      SDL_RenderDrawPoint(renderer, x, y);</a>
<a class="sourceLine" id="cb2-43" title="43">    }</a>
<a class="sourceLine" id="cb2-44" title="44">  }</a>
<a class="sourceLine" id="cb2-45" title="45"></a>
<a class="sourceLine" id="cb2-46" title="46">  <span class="co">// Render everything we&#39;ve drawn to the canvas.</span></a>
<a class="sourceLine" id="cb2-47" title="47">  SDL_RenderPresent(renderer);</a>
<a class="sourceLine" id="cb2-48" title="48"></a>
<a class="sourceLine" id="cb2-49" title="49">  <span class="co">// SDL_Quit();</span></a>
<a class="sourceLine" id="cb2-50" title="50">}</a></code></pre></div>
<p>You can see that this application is still fairly small-it’s a single file containing 50 lines of code-but this time I’m also using some external APIs, like <a href="https://en.wikipedia.org/wiki/Simple_DirectMedia_Layer">SDL library</a> for graphics as well as <a href="https://en.cppreference.com/w/cpp/numeric/complex">complex numbers</a> from the C++ standard library.</p>
<p>I’m going to compile it with the same <code>-g</code> flag as above to include debug information, and also I’ll ask Emscripten to provide the SDL2 library and allow arbitrarily-sized memory:</p>
<pre class="devsite-terminal devsite-click-to-copy">
emcc -g mandelbrot.cc -o mandelbrot.html \
     -s USE_SDL=2 \
     -s ALLOW_MEMORY_GROWTH=1
</pre>
<p>When I visit the generated page in the browser, I can see the beautiful fractal shape with some random colors:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/nBKJpU8uQ8z3M2PbUzgO.png”, alt=“Demo page”, width=“800”, height=“441” %}</p>
<p>When I open DevTools, once again, I can see the original C++ file. This time, however, we don’t have an error in the code (whew!), so let’s set some breakpoint at the beginning of our code instead.</p>
<p>When we reload the page again, the debugger will pause right inside our C++ source:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/kWLHwNkx2qyKoEfc32T5.png”, alt=“DevTools paused on the <code>SDL_Init</code> call”, width=“800”, height=“325” %}</p>
<p>We can already see all our variables on the right, but only <code>width</code> and <code>height</code> are initialized at the moment, so there isn’t much to inspect.</p>
<p>Let’s set another breakpoint inside our main Mandelbrot loop, and resume execution to skip a bit forward.</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/dYkxFRBTFC5xTCj6JYYj.png”, alt=“DevTools paused inside the nested loops”, width=“800”, height=“325” %}</p>
<p>At this point our <code>palette</code> has been filled with some random colors, and we can expand both the array itself, as well as the individual <code>SDL_Color</code> structures and inspect their components to verify that everything looks good (for example, that “alpha” channel is always set to full opacity). Similarly, we can expand and check the real and imaginary parts of the complex number stored in the <code>center</code> variable.</p>
<p>If you want to access a deeply nested property that is otherwise hard to navigate to via the <strong>Scope</strong> view, you can use the <strong>Console</strong> evaluation, too! However, note that more complex C++ expressions are not yet supported.</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/941JrBrs0T1fEv6YoLub.png”, alt=“Console panel showing the result of <code>palette[10].r</code>”, width=“800”, height=“325” %}</p>
<p>Let’s resume execution a few times and we can see how the inner <code>x</code> is changing as well-either by looking in the <strong>Scope</strong> view again, adding the variable name to the watch list, evaluating it in the console, or by hovering over the variable in the source code:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/mJMZyOZekEnRw2KQR1Ew.png”, alt=“Tooltip over the variable <code>x</code> in the source showing its value <code>3</code>”, width=“800”, height=“325” %}</p>
<p>From here, we can step-in or step-over C++ statements, and observe how other variables are changing too:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/SwpdTR1jGWJiYnncY7RM.png”, alt=“Tooltips and Scope view showing values of <code>color</code>, <code>point</code> and other variables”, width=“800”, height=“325” %}</p>
<p>Okay, so this all works great when a debug information is available, but what if we want to debug a code that wasn’t built with the debugging options?</p>
<h2 id="raw-webassembly-debugging-raw">Raw WebAssembly debugging {: #raw }</h2>
<p>For example, we asked Emscripten to provide a prebuilt SDL library for us, instead of compiling it ourselves from the source, so-at least currently-there’s no way for the debugger to find associated sources. Let’s step-in again to get into the <code>SDL_RenderDrawColor</code>:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/Jxpkixgqq4wighsvwZIg.png”, alt=“DevTools showing disassembly view of <code>mandelbrot.wasm</code>”, width=“800”, height=“325” %}</p>
<p>We’re back to the raw WebAssembly debugging experience.</p>
<p>Now, it looks a bit scary and isn’t something most Web developers will ever need to deal with, but occasionally you might want to debug a library built without debug information-whether because it’s a 3<sup>rd</sup>-party library you have no control over, or because you’re running into one of those bugs that occurs only on production.</p>
<p>To aid in those cases, we’ve made some improvements to the basic debugging experience, too.</p>
<p>First of all, if you used raw WebAssembly debugging before, you might notice that the entire disassembly is now shown in a single file-no more guessing which function a <strong>Sources</strong> entry <code>wasm-53834e3e/ wasm-53834e3e-7</code> possibly corresponds to.</p>
<h3 id="new-name-generation-scheme-names">New name generation scheme {: #names }</h3>
<p>We improved names in the disassembly view, too. Previously you’d see just numeric indices, or, in case of functions, no name at all.</p>
<p>Now we’re generating names similarly to other disassembly tools, by using hints from the <a href="https://webassembly.github.io/spec/core/appendix/custom.html#name-section">WebAssembly name section</a>, import/export paths and, finally, if everything else fails, generating them based on the type and the index of the item like <code>$func123</code>. You can see how, in the screenshot above, this already helps to get slightly more readable stacktraces and disassembly.</p>
<p>When there is no type information available, it might be hard to inspect any values besides the primitives-for example, pointers will show up as regular integers, with no way of knowing what’s stored behind them in memory.</p>
<h3 id="memory-inspection-memory-inspector">Memory inspection {: #memory-inspector }</h3>
<p>Previously, you could only expand the WebAssembly memory object, represented by <code>env.memory</code> in the <strong>Scope</strong> view-to look up individual bytes. This worked in some trivial scenarios, but wasn’t particularly convenient to expand and didn’t allow to reinterpret data in formats other than byte values. We’ve added a new feature to help with this, too: a linear memory inspector.</p>
<p>If you right-click on the <code>env.memory</code>, you should now see a new option called <strong>Inspect memory</strong>:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/Q6cxJDPsaxbHOfrgfUsn.png”, alt=“Context menu on the <code>env.memory</code> in the Scope pane showing an ‘Inspect Memory’ item”, width=“800”, height=“325” %}</p>
<p>Once clicked, it will bring up a <strong>Memory Inspector</strong>, in which you can inspect the WebAssembly memory in hexadecimal and ASCII views, navigate to specific addresses, as well as interpret the data in different formats:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/9XZ8ezGg7GmqmAjKwOiR.png”, alt=“Memory Inspector pane in DevTools showing a hex and ASCII views of the memory”, width=“800”, height=“537” %}</p>
<h2 id="advanced-scenarios-and-caveats-advanced">Advanced scenarios and caveats {: #advanced }</h2>
<h3 id="profiling-webassembly-code-profiling">Profiling WebAssembly code {: #profiling }</h3>
<p>When you open DevTools, WebAssembly code gets “tiered down” to an unoptimized version to enable debugging. This version is a lot slower, which means that you can’t rely on <code>console.time</code>, <code>performance.now</code> and other methods of measuring speed of your code while DevTools are open, as the numbers you get won’t represent the real-world performance at all.</p>
<p>Instead, you should use the DevTools <a href="/docs/devtools/evaluate-performance/reference/">Performance panel</a> which will run the code at the full speed and provide you with a detailed breakdown of the time spent in different functions:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/RuyMdSabxONp2XftGgyj.png”, alt=“Profiling panel showing various Wasm functions”, width=“800”, height=“413” %}</p>
<p>Alternatively, you can run your application with DevTools closed, and open them once finished to inspect the <strong>Console</strong>.</p>
<p>We’ll be improving profiling scenarios in the future, but for now it’s a caveat to be aware of. If you want to learn more about WebAssembly tiering scenarios, check out our docs on <a href="https://v8.dev/docs/wasm-compilation-pipeline">WebAssembly compilation pipeline</a>.</p>
<h3 id="building-and-debugging-on-different-machines-including-docker-host-path-mapping">Building and debugging on different machines (including Docker / host) {: #path-mapping }</h3>
<p>When building in a Docker, virtual machine, or on a remote build server, you will likely run into situations where the paths to the source files used during the build don’t match the paths on your own filesystem where the Chrome DevTools are running. In this case, files will show up in the <strong>Sources</strong> panel but fail to load.</p>
<p>To fix this issue, we have implemented a path mapping functionality in the C/C++ extension options. You can use it to remap arbitrary paths and help the DevTools locate sources.</p>
<p>For example, if the project on your host machine is under a path <code>C:\src\my_project</code>, but was built inside a Docker container where that path was represented as <code>/mnt/c/src/my_project</code>, you can remap it back during debugging by specifying those paths as prefixes:</p>
<p>{% Img src=“image/dPDCek3EhZgLQPGtEG3y0fTn4v82/M9z9cm1piNiu02OUiWb8.png”, alt=“Options page of the C/C++ debugging extension”, width=“800”, height=“268” %}</p>
<p>The first matched prefix “wins”. If you’re familiar with other C++ debuggers, this option is similar to the <code>set substitute-path</code> command in GDB or a <code>target.source-map</code> setting in LLDB.</p>
<h3 id="debugging-optimized-builds-release-builds">Debugging optimized builds {: #release-builds }</h3>
<p>Like with any other languages, debugging works best if optimizations are disabled. Optimizations might inline functions one into another, reorder code, or remove parts of the code altogether-and all of this has a chance to confuse the debugger and, consequently, you as the user.</p>
<p>If you don’t mind a more limited debugging experience and still want to debug an optimized build, then most of the optimizations will work as expected, except for function inlining. We plan to address the remaining issues in the future, but, for now, please use <code>-fno-inline</code> to disable it when compiling with any <code>-O</code> level optimizations, e.g.:</p>
<pre class="devsite-terminal devsite-click-to-copy">
emcc -g temp.c -o temp.html \
     -O3 -fno-inline
</pre>
<h3 id="separating-the-debug-information-separate-dwarf">Separating the debug information {: #separate-dwarf }</h3>
<p>Debug information preserves lots of details about your code, defined types, variables, functions, scopes, and locations-anything that might be useful to the debugger. As a result, it often can be larger than the code itself.</p>
<p>To speed up loading and compilation of the WebAssembly module, you might want to split out this debug information into a separate WebAssembly file. To do that in Emscripten, pass a <code>-gseparate-dwarf=…</code> flag with a desired filename:</p>
<pre class="devsite-terminal devsite-click-to-copy">
emcc -g temp.c -o temp.html \
     -gseparate-dwarf=temp.debug.wasm
</pre>
<p>In this case, the main application will only store a filename <code>temp.debug.wasm</code>, and the helper extension will be able to locate and load it when you open DevTools.</p>
<p>When combined with optimizations like described above, this feature can be even used to ship almost-optimized production builds of your application, and later debug them with a local side file. In this case, we’ll additionally need to override the stored URL to help the extension find the side file, for example:</p>
<pre class="devsite-terminal devsite-click-to-copy">
emcc -g temp.c -o temp.html \
     -O3 -fno-inline \
     -gseparate-dwarf=temp.debug.wasm \
     -s SEPARATE_DWARF_URL=file://[local path to temp.debug.wasm]
</pre>
<h2 id="to-be-continued-future-plans">To be continued… {: #future-plans }</h2>
<p>Whew, that was a lot of new features!</p>
<p>With all those new integrations, Chrome DevTools becomes a viable, powerful, debugger not only for JavaScript, but also for C and C++ apps, making it easier than ever to take apps, built in a variety of technologies and bring them to a shared, cross-platform Web.</p>
<p>However, our journey is not over yet. Some of the things we’ll be working on from here on:</p>
<ul>
<li>Cleaning up the rough edges in the debugging experience.</li>
<li>Adding support for custom type formatters.</li>
<li>Working on improvements to the <a href="/docs/devtools/evaluate-performance/reference/">profiling</a> for WebAssembly apps.</li>
<li>Adding support for <a href="/docs/devtools/coverage">code coverage</a> to make it easier to find unused code.</li>
<li>Improving support for expressions in console evaluation.</li>
<li>Adding support for more languages.</li>
<li>…and more!</li>
</ul>
<p>Meanwhile, please help us out by trying the current beta on your own code and reporting any found issues to <a href="https://bugs.chromium.org/p/chromium/issues/entry?template=DevTools+issue">https://bugs.chromium.org/p/chromium/issues/entry?template=DevTools+issue</a>.</p>
</body>
</html>
