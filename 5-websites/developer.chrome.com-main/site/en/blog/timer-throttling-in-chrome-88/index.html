<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta name="dcterms.date" content="2021-01-18" />
  <title>Heavy throttling of chained JS timers beginning in Chrome 88</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<header id="title-block-header">
<h1 class="title">Heavy throttling of chained JS timers beginning in Chrome 88</h1>
<p class="date">2021-01-18</p>
</header>
<p>Chrome 88 (January 2021) will heavily throttle chained JavaScript timers for hidden pages in particular conditions. This will reduce CPU usage, which will also reduce battery usage. There are some edge cases where this will change behavior, but timers are often used where a different API would be more efficient, and more reliable.</p>
<p>OK, that was pretty jargon heavy, and a bit ambiguous. Let’s dig in…</p>
<h2 id="terminology">Terminology</h2>
<h3 id="hidden-pages">Hidden pages</h3>
<p>Generally, <em>hidden</em> means a different tab is active, or the window has been minimized, but browsers may consider a page hidden whenever its content is totally not-visible. Some browsers go further than others here, but you can always use the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Page_Visibility_API">page visibility API</a> to track when the browser thinks visibility has changed.</p>
<h3 id="javascript-timers">JavaScript timers</h3>
<p>By <em>JavaScript timers</em> I mean <code>setTimeout</code> and <code>setInterval</code>, which allow you to schedule a callback sometime in the future. Timers are useful, and they aren’t going away, but sometimes they’re used to poll state when an event would be more efficient, and more accurate.</p>
<h3 id="chained-timers">Chained timers</h3>
<p>If you call <code>setTimeout</code> in the same task as a <code>setTimeout</code> callback, the second invocation is ‘chained’. With <code>setInterval</code>, each iteration is part of the <em>chain</em>. This might be easier to understand with code:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">let</span> chainCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-2" title="2"></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="at">setInterval</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb1-4" title="4">  chainCount<span class="op">++;</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`This is number </span><span class="sc">${</span>chainCount<span class="sc">}</span><span class="vs"> in the chain`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="op">},</span> <span class="dv">500</span>)<span class="op">;</span></a></code></pre></div>
<p>And:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">let</span> chainCount <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb2-2" title="2"></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">function</span> <span class="at">setTimeoutChain</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb2-4" title="4">  <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb2-5" title="5">    chainCount<span class="op">++;</span></a>
<a class="sourceLine" id="cb2-6" title="6">    <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`This is number </span><span class="sc">${</span>chainCount<span class="sc">}</span><span class="vs"> in the chain`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="at">setTimeoutChain</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb2-8" title="8">  <span class="op">},</span> <span class="dv">500</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-9" title="9"><span class="op">}</span></a></code></pre></div>
<h2 id="how-the-throttling-works">How the throttling works</h2>
<p>The throttling happens in stages:</p>
<h3 id="minimal-throttling">Minimal throttling</h3>
<p>This happens to timers that are scheduled when <em>any</em> of the following is true:</p>
<ul>
<li>The page is <em>visible</em>.</li>
<li>The page has made noises in the past 30 seconds. This can be from any of the sound-making APIs, but a silent audio track doesn’t count.</li>
</ul>
<p>The timer isn’t throttled, unless the requested timeout is less than 4ms, and the chain count is 5 or greater, in which case the timeout is set to 4ms. This isn’t new; browsers have done this for many years.</p>
<h3 id="throttling">Throttling</h3>
<p>This happens to timers that are scheduled when <em>minimal throttling</em> doesn’t apply, and <em>any</em> of the following is true:</p>
<ul>
<li>The <em>chain count</em> is less than 5.</li>
<li>The page has been <em>hidden</em> for less than 5 minutes.</li>
<li>WebRTC is in use. Specifically, there’s an <code>RTCPeerConnection</code> with an ‘open’ <code>RTCDataChannel</code> or a ‘live’ <code>MediaStreamTrack</code>.</li>
</ul>
<p>The browser will check timers in this group once per <strong>second</strong>. Because they’re only checked once per second, timers with a similar timeout will batch together, consolidating the time the tab needs to run code. This isn’t new either; browsers have been doing this to some extent for years.</p>
<h3 id="intensive-throttling">Intensive throttling</h3>
<p>OK, here’s the new bit in Chrome 88. Intensive throttling happens to timers that are scheduled when none of the <em>minimal throttling</em> or <em>throttling</em> conditions apply, and <em>all</em> of the following conditions are true:</p>
<ul>
<li>The page has been <em>hidden</em> for more than 5 minutes.</li>
<li>The <em>chain count</em> is 5 or greater.</li>
<li>The page has been silent for at least 30 seconds.</li>
<li>WebRTC is not in use.</li>
</ul>
<p>In this case, the browser will check timers in this group once per <strong>minute</strong>. Similar to before, this means timers will batch together in these minute-by-minute checks.</p>
<h2 id="workarounds">Workarounds</h2>
<p>There’s usually a better alternative to a timer, or timers can be combined with something else to be kinder to CPUs and battery life.</p>
<h3 id="state-polling">State polling</h3>
<p>This is the most common (mis)use of timers, where they’re used to continually check or <a href="https://en.wikipedia.org/wiki/Polling_%28computer_science%29">poll</a> to see if something has changed. In most cases there’s a <a href="https://en.wikipedia.org/wiki/Push_technology">push</a> equivalent, where the thing tells you about the change when it happens, so you don’t have to keep checking. Look to see if there’s an event that achieves the same thing.</p>
<p>Some examples:</p>
<ul>
<li>If you need to know when an element enters in the viewport, use <a href="https://developer.mozilla.org/en-US/docs/Web/API/Intersection_Observer_API"><code>IntersectionObserver</code></a>.</li>
<li>If you need to know when an element changes size, use <a href="https://web.dev/resize-observer/"><code>ResizeObserver</code></a>.</li>
<li>If you need to know when the DOM changes, use <a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver"><code>MutationObserver</code></a>, or maybe <a href="https://developer.mozilla.org/en-US/docs/Web/Web_Components/Using_custom_elements">custom element lifecycle callbacks</a>.</li>
<li>Rather than poll a server, consider <a href="https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API">web sockets</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/EventSource">server-sent events</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/API/Push_API">push messages</a>, or <a href="https://web.dev/fetch-upload-streaming/#previously-on-the-exciting-adventures-of-fetch-streams">fetch streams</a>.</li>
<li>If you need to react to stage changes in audio/video, <a href="https://html.spec.whatwg.org/multipage/media.html#mediaevents">use events like <code>timeupdate</code> and <code>ended</code></a>, or <a href="https://web.dev/requestvideoframecallback-rvfc/"><code>requestVideoFrameCallback</code></a> if you need to do something with each frame.</li>
</ul>
<p>There’s also <a href="https://web.dev/notification-triggers/">notification triggers</a> if you want to show a notification at a particular time.</p>
<h3 id="animation">Animation</h3>
<p>Animation is a visual thing, so it shouldn’t use CPU time when the page is <em>hidden</em>.</p>
<p><a href="https://developer.mozilla.org/en-US/docs/Web/API/window/requestAnimationFrame"><code>requestAnimationFrame</code></a> is much better at scheduling animation work than JavaScript timers. It synchronizes with the refresh rate of the device, ensuring you only get one callback per displayable frame, and you get the maximum amount of time to construct that frame. Also, <code>requestAnimationFrame</code> will wait for the page to be visible, so it doesn’t use any CPU when the page is hidden.</p>
<p>If you can declare your whole animation up-front, consider using <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/animation">CSS animations</a> or the <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Animations_API">web animations API</a>. These have the same advantages as <code>requestAnimationFrame</code>, but the browser can perform additional optimizations like automatic compositing, and they’re generally easier to use.</p>
<p>If your animation is low-framerate (like a blinking cursor), timers are still the best option right now, but you can combine them with <code>requestAnimationFrame</code> to get the best of both worlds:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">function</span> <span class="at">animationInterval</span>(ms<span class="op">,</span> signal<span class="op">,</span> callback) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="kw">const</span> start <span class="op">=</span> <span class="va">document</span>.<span class="va">timeline</span>.<span class="at">currentTime</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3"></a>
<a class="sourceLine" id="cb3-4" title="4">  <span class="kw">function</span> <span class="at">frame</span>(time) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="cf">if</span> (<span class="va">signal</span>.<span class="at">aborted</span>) <span class="cf">return</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="at">callback</span>(time)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="at">scheduleFrame</span>(time)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10">  <span class="kw">function</span> <span class="at">scheduleFrame</span>(time) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-11" title="11">    <span class="kw">const</span> elapsed <span class="op">=</span> time <span class="op">-</span> start<span class="op">;</span></a>
<a class="sourceLine" id="cb3-12" title="12">    <span class="kw">const</span> roundedElapsed <span class="op">=</span> <span class="va">Math</span>.<span class="at">round</span>(elapsed / ms) <span class="op">*</span> ms<span class="op">;</span></a>
<a class="sourceLine" id="cb3-13" title="13">    <span class="kw">const</span> targetNext <span class="op">=</span> start <span class="op">+</span> roundedElapsed <span class="op">+</span> ms<span class="op">;</span></a>
<a class="sourceLine" id="cb3-14" title="14">    <span class="kw">const</span> delay <span class="op">=</span> targetNext <span class="op">-</span> <span class="va">performance</span>.<span class="at">now</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="at">requestAnimationFrame</span>(frame)<span class="op">,</span> delay)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-16" title="16">  <span class="op">}</span></a>
<a class="sourceLine" id="cb3-17" title="17"></a>
<a class="sourceLine" id="cb3-18" title="18">  <span class="at">scheduleFrame</span>(start)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-19" title="19"><span class="op">}</span></a></code></pre></div>
<p>Usage:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">const</span> controller <span class="op">=</span> <span class="kw">new</span> <span class="at">AbortController</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb4-2" title="2"></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">// Create an animation callback every second:</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="at">animationInterval</span>(<span class="dv">1000</span><span class="op">,</span> <span class="va">controller</span>.<span class="at">signal</span><span class="op">,</span> time <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb4-5" title="5">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;tick!&#39;</span><span class="op">,</span> time)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb4-7" title="7"></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="co">// And stop it:</span></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="va">controller</span>.<span class="at">abort</span>()<span class="op">;</span></a></code></pre></div>
<h2 id="testing">Testing</h2>
<p>This change will be enabled for all Chrome users in Chrome 88 (January 2021). It’s currently enabled for 50% of Chrome Beta, Dev, and Canary users. If you want to test it, use this command line flag when launching Chrome Beta, Dev, or Canary:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb5-1" title="1"><span class="ex">--enable-features</span>=<span class="st">&quot;IntensiveWakeUpThrottling:grace_period_seconds/10,OptOutZeroTimeoutTimersFromThrottling,AllowAggressiveThrottlingWithWebSocket&quot;</span></a></code></pre></div>
<p>The <code>grace_period_seconds/10</code> argument causes intense throttling to kick in after 10 seconds of the page being hidden, rather than the full 5 minutes, making it easier to see the impact of the throttling.</p>
<h2 id="the-future">The future</h2>
<p>Since timers are a source of excessive CPU use, we’re going to continue to look at ways we can throttle them without breaking web content, and APIs we can add/change to meet use-cases. Personally, I’d like to eliminate the need for <code>animationInterval</code> in favor of efficient low-frequency animation callbacks. If you have any questions, please <a href="https://twitter.com/jaffathecake/">reach out to me on Twitter</a>!</p>
<p>Header photo by <a href="https://unsplash.com/@heatherz">Heather Zabriskie</a> on <a href="https://unsplash.com/photos/yBzrPGLjMQw">Unsplash</a>.</p>
</body>
</html>
