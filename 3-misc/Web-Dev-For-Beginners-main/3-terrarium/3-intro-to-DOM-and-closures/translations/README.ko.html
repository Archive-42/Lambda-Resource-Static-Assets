<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README.ko</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="terrarium-프로젝트-파트-3-dom-조작과-클로저">Terrarium 프로젝트 파트 3: DOM 조작과 클로저</h1>
<p><img src="/sketchnotes/webdev101-js.png" alt="DOM and a closure" /> &gt; Sketchnote by <a href="https://twitter.com/girlie_mac">Tomomi Imura</a></p>
<h2 id="강의-전-퀴즈">강의 전 퀴즈</h2>
<p><a href="https://nice-beach-0fe9e9d0f.azurestaticapps.net/quiz/19?loc=ko">Pre-lecture quiz</a></p>
<h3 id="소개">소개</h3>
<p>DOM 또는 “Document Object Model”을 조작하는 것은 웹 개발의 핵심입니다. <a href="https://developer.mozilla.org/docs/Web/API/Document_Object_Model/Introduction">MDN</a>에 따르면, “The Document Object Model (DOM) is the data representation of the objects that comprise the structure and content of a document on the web.” 이라고 합니다. 웹의 DOM 조작과 관련하여 간혹 DOM을 관리하기 위해 순수 JavaScript 대신 JavaScript 프레임워크를 도전하게 되는 원동력이지만, 우리는 스스로 관리할 것입니다!</p>
<p>추가로, 이 강의에서는 <a href="https://developer.mozilla.org/docs/Web/JavaScript/Closures">JavaScript closure</a>에 대한 아이디어를 소개합니다. 내부 함수가 외부 함수의 범위에 접근할 수 있도록 합니다.</p>
<p>DOM을 조작하기 위해 클로저를 사용할 예정입니다.</p>
<blockquote>
<p>DOM을 웹 페이지 문서를 제어할 수 있는 모든 방법으로 나타낼 수 있는 트리로 생각하십시오. 프로그래머가 선택한 프로그래밍 언어를 사용하여 DOM에 접근하고 편집, 변경, 재배치하며 관리할 수 있는 다양한 API(Application Program Interfaces)가 작성되어 있습니다.</p>
</blockquote>
<figure>
<img src=".././images/dom-tree.png" alt="DOM tree representation" /><figcaption>DOM tree representation</figcaption>
</figure>
<blockquote>
<p>DOM과 참조하는 HTML 마크업의 표현입니다. From <a href="https://www.researchgate.net/publication/221417012_Profile-Based_Focused_Crawler_for_Social_Media-Sharing_Websites">Olfa Nasraoui</a></p>
</blockquote>
<p>이 강의에서는, 사용자가 페이지에서 식물을 조작할 수 있는 JavaScript를 작성하여 대화식 terrarium 프로젝트를 완료합니다.</p>
<h3 id="준비물">준비물</h3>
<p>terrarium에 대한 HTML과 CSS를 작성해두어야 합니다. 이 강의가 끝나면 식물을 드래그하여 terrarium에서 이동할 수 있습니다.</p>
<h3 id="작업">작업</h3>
<p>terrarium 폴더에서, <code>script.js</code>라고 불리는 파일을 만듭니다. 파일의 <code>&lt;head&gt;</code> 부분에 넣습니다:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb1-1" title="1">    <span class="kw">&lt;script</span><span class="ot"> src=</span><span class="st">&quot;./script.js&quot;</span><span class="ot"> defer</span><span class="kw">&gt;&lt;/script&gt;</span></a></code></pre></div>
<h2 id="note-외부-javascript-파일을-html-파일로-가져올-때-defer-를-사용하여-html-파일이-완전히-불러질-때만-javascript가-실행되도록-합니다.-html-파일이-파싱되는-동안-스크립트를-실행할-수-있는-async-속성을-사용할-수-있지만-우리는-드래그-스크립트를-실행하기-전에-html-요소를-완전히-드래그할-수-있어야-한다는-점이-중요합니다.">&gt; Note: 외부 JavaScript 파일을 html 파일로 가져올 때 <code>defer</code> 를 사용하여 HTML 파일이 완전히 불러질 때만 JavaScript가 실행되도록 합니다. HTML 파일이 파싱되는 동안 스크립트를 실행할 수 있는 <code>async</code> 속성을 사용할 수 있지만, 우리는 드래그 스크립트를 실행하기 전에 HTML 요소를 완전히 드래그할 수 있어야 한다는 점이 중요합니다.</h2>
<h2 id="dom-요소">DOM 요소</h2>
<p>가장 먼저 할 일은 DOM에서 조작하려는 요소에 대한 참조를 만드는 것입니다. 우리의 경우, 현재 사이드바에서 대기하고 있는 14개의 식물입니다.</p>
<h3 id="작업-1">작업</h3>
<div class="sourceCode" id="cb2"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb2-1" title="1">dragElement(document.getElementById(&#39;plant1&#39;));</a>
<a class="sourceLine" id="cb2-2" title="2">dragElement(document.getElementById(&#39;plant2&#39;));</a>
<a class="sourceLine" id="cb2-3" title="3">dragElement(document.getElementById(&#39;plant3&#39;));</a>
<a class="sourceLine" id="cb2-4" title="4">dragElement(document.getElementById(&#39;plant4&#39;));</a>
<a class="sourceLine" id="cb2-5" title="5">dragElement(document.getElementById(&#39;plant5&#39;));</a>
<a class="sourceLine" id="cb2-6" title="6">dragElement(document.getElementById(&#39;plant6&#39;));</a>
<a class="sourceLine" id="cb2-7" title="7">dragElement(document.getElementById(&#39;plant7&#39;));</a>
<a class="sourceLine" id="cb2-8" title="8">dragElement(document.getElementById(&#39;plant8&#39;));</a>
<a class="sourceLine" id="cb2-9" title="9">dragElement(document.getElementById(&#39;plant9&#39;));</a>
<a class="sourceLine" id="cb2-10" title="10">dragElement(document.getElementById(&#39;plant10&#39;));</a>
<a class="sourceLine" id="cb2-11" title="11">dragElement(document.getElementById(&#39;plant11&#39;));</a>
<a class="sourceLine" id="cb2-12" title="12">dragElement(document.getElementById(&#39;plant12&#39;));</a>
<a class="sourceLine" id="cb2-13" title="13">dragElement(document.getElementById(&#39;plant13&#39;));</a>
<a class="sourceLine" id="cb2-14" title="14">dragElement(document.getElementById(&#39;plant14&#39;));</a></code></pre></div>
<p>여기서 어떤 일이 일어나고 있나요? 특정 Id의 요소를 찾기 위해 문서를 참조하려고 해당 DOM을 봅니다. HTML에 대한 첫번째 강의에서 각 식물 이미지(<code>id="plant1"</code>)에 개별 Id를 준 것을 기억하시나요? 이제 그 노력을 쓰겠습니다. 각 요소를 식별한 후, 1분 안에 작성될 <code>dragElement</code>라고 불리는 함수에 해당 아이템을 전달합니다. 따라서 HTML의 요소는 이제 드래그를 할 수 있거나 곧 합니다.</p>
<p>✅ 왜 우리는 Id로 요소를 참조하나요? CSS 클래스가 아닌 이유는 무엇일까요? 이 질문에 답하기 위해 CSS에 대한 전 강의를 참조할 수 있습니다.</p>
<hr />
<h2 id="클로저">클로저</h2>
<p>이제 내부 함수를 감싸는 외부 함수인 dragElement 클로저를 만들 준비가 되었습니다(이 경우에는, 3개가 있습니다).</p>
<p>클로저는 하나 이상의 함수가 외부 함수의 범위로 접근하는 순간 유용합니다. 예시는 다음과 같습니다:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">function</span> <span class="at">displayCandy</span>()<span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="kw">let</span> candy <span class="op">=</span> [<span class="st">&#39;jellybeans&#39;</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="kw">function</span> <span class="at">addCandy</span>(candyType) <span class="op">{</span></a>
<a class="sourceLine" id="cb3-4" title="4">        <span class="va">candy</span>.<span class="at">push</span>(candyType)</a>
<a class="sourceLine" id="cb3-5" title="5">    <span class="op">}</span></a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="at">addCandy</span>(<span class="st">&#39;gumdrops&#39;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="op">}</span></a>
<a class="sourceLine" id="cb3-8" title="8"><span class="at">displayCandy</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="va">console</span>.<span class="at">log</span>(candy)</a></code></pre></div>
<p>이 예제에서, displayCandy 함수는 새 캔디 타입을 이미 존재하는 배열로 푸시하는 함수를 감쌉니다. 이 코드를 실행한다면, <code>candy</code> 배열은 지역 변수(클로저 로컬)이므로 정의되지 않습니다.</p>
<p>✅ <code>candy</code> 배열에 어떻게 접근할 수 있습니까? 클로저 밖으로 이동해보세요. 이 방식은 배열이 클로저의 로컬뿐만 아니라, 전역 범위에서도 사용할 수 있습니다.</p>
<h3 id="작업-2">작업</h3>
<p><code>script.js</code>의 요소 선언 아래, 함수를 만듭니다:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">function</span> <span class="at">dragElement</span>(terrariumElement) <span class="op">{</span></a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="co">//set 4 positions for positioning on the screen</span></a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="kw">let</span> pos1 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb4-4" title="4">        pos2 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb4-5" title="5">        pos3 <span class="op">=</span> <span class="dv">0</span><span class="op">,</span></a>
<a class="sourceLine" id="cb4-6" title="6">        pos4 <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-7" title="7">    <span class="va">terrariumElement</span>.<span class="at">onpointerdown</span> <span class="op">=</span> pointerDrag<span class="op">;</span></a>
<a class="sourceLine" id="cb4-8" title="8"><span class="op">}</span></a></code></pre></div>
<p><code>dragElement</code>는 스크립트 상단의 선언에서 <code>terrariumElement</code> 객체를 가져옵니다. 그러고, 함수에 전달된 객체의 일부 로컬 위치를 <code>0</code>으로 설정합니다. 클로저 안에서 드래그 앤 드롭 기능을 각 요소에 추가할 때 각 요소에 대해 조작될 지역 변수입니다. terrarium에 드래그된 요소로 채워지므로, 애플리케이션은 배치된 위치를 추적해야 합니다.</p>
<p>추가로, 이 함수에 전달되는 terrariumElement에는 DOM 관리에 도움이 되도록 설계된 <a href="https://developer.mozilla.org/docs/Web/API">web APIs</a>의 일부인 <code>pointerdown</code> 이벤트가 할당됩니다. <code>onpointerdown</code>은 버튼이 눌리거나 드래그 하는 요소가 터치될 때 발생합니다. 이 이벤트 핸들러는 몇 가지 예외를 제외하고, <a href="https://caniuse.com/?search=onpointerdown">웹과 모바일 브라우저</a> 다 작동합니다.</p>
<p>✅ <a href="https://developer.mozilla.org/docs/Web/API/GlobalEventHandlers/onclick">event handler <code>onclick</code></a>은 크로스 브라우저 지원이 훨씬 더 많습니다. 왜 여기서 사용하지 않나요? 여기에서 만들고자 하는 정확한 화면 상호작용 타입에 대해 생각해보세요.</p>
<hr />
<h2 id="pointerdrag-함수">Pointerdrag 함수</h2>
<p>terrariumElement를 드래그할 준비가 되었습니다; <code>onpointerdown</code> 이벤트가 시작되면, pointerDrag 함수가 호출됩니다. 줄 바로 아래에 해당 함수를 추가하시기 바랍니다: <code>terrariumElement.onpointerdown = pointerDrag;</code>:</p>
<h3 id="작업-3">작업</h3>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">function</span> <span class="at">pointerDrag</span>(e) <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="va">e</span>.<span class="at">preventDefault</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(e)<span class="op">;</span></a>
<a class="sourceLine" id="cb5-4" title="4">    pos3 <span class="op">=</span> <span class="va">e</span>.<span class="at">clientX</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-5" title="5">    pos4 <span class="op">=</span> <span class="va">e</span>.<span class="at">clientY</span><span class="op">;</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="op">}</span></a></code></pre></div>
<p>몇 가지 일이 발생합니다. 처음으로, <code>e.preventDefault();</code>를 사용하여 포인터 다운 시 일상적으로 발생하는 기본 이벤트가 발생하지 않도록 합니다. 이러면 인터페이스의 동작을 더 잘 제어할 수 있습니다.</p>
<blockquote>
<p>스크립트 파일을 완전히 작성했으면 이 줄로 돌아와서 <code>e.preventDefault()</code> 없이 시도해보세요. - 어떻게 되나요?</p>
</blockquote>
<p>두 번째로는, 브라우저 창에서 <code>index.html</code>을 열고, 인터페이스를 검사합니다. 식물을 클릭하면, ‘e’ 이벤트가 캡처되는 방식을 볼 수 있습니다. 이벤트를 뜯어보면서 한 번의 포인터 다운 이벤트로 얼마나 많은 정보가 수집되는지 확인해보시기 바랍니다!</p>
<p>다음으로 지역 변수 ’pos3’과 ’pos4’가 어떻게 e.clientX 로 설정되어 있는 지 확인합니다. 검사 창에서 <code>e</code> 값을 찾을 수 있습니다. 이 값은 식물을 클릭하거나 터치하는 순간 식물의 x 와 y 좌표를 캡처합니다. 식물을 클릭하고 드래그할 때 식물의 동작을 세밀하게 제어하여 좌표를 추적해야 합니다.</p>
<p>✅ 하나의 앱이 하나의 큰 클로저로 만들어진 이유가 더 분명해지나요? 아니라면, 14개의 드래그 가능한 식물을 어떻게 각각의 범위를 지킬까요?</p>
<p><code>pos4 = e.clientY</code> 아래에 포인터 이벤트 조작을 2개 더 추가하여 함수 초기화를 완료합니다:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb6-1" title="1">document.onpointermove = elementDrag;</a>
<a class="sourceLine" id="cb6-2" title="2">document.onpointerup = stopElementDrag;</a></code></pre></div>
<p>제 식물을 이동할 때 포인터와 함께 식물을 끌고, 식물 선택을 취소할 때 드래그 제스처를 중지하도록 지정합니다. <code>onpointermove</code> 와 <code>onpointerup</code>은 모두 <code>onpointerdown</code>과 동일한 API의 일부입니다. 아직 <code>elementDrag</code> 및 <code>stopElementDrag</code> 함수를 정의하지 않아 인터페이스에서 오류가 발생하므로, 다음에 작성하십시오.</p>
<h2 id="elementdrag와-stopelementdrag-함수">elementDrag와 stopElementDrag 함수</h2>
<p>식물을 드래그하고 멈출 때 일어나는 일을 처리하는 두 내부 함수를 더 추가하여 클로저를 완료합니다. 원하는 동작은 언제든지 식물을 드래그하여 화면의 아무 곳에 둘 수 있다는 것입니다. 이 인터페이스는 식물을 추가, 제거 그리고 재배치하여 원하는대로 terrarium을 정확하게 디자인할 수 있도록 (예를 들어 drop zone이 없음)하는 것에 의견이 없습니다.</p>
<h3 id="작업-4">작업</h3>
<p><code>pointerDrag</code>의 닫는 중괄호 바로 뒤에 <code>elementDrag</code> 함수를 추가합니다:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">function</span> <span class="at">elementDrag</span>(e) <span class="op">{</span></a>
<a class="sourceLine" id="cb7-2" title="2">    pos1 <span class="op">=</span> pos3 <span class="op">-</span> <span class="va">e</span>.<span class="at">clientX</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-3" title="3">    pos2 <span class="op">=</span> pos4 <span class="op">-</span> <span class="va">e</span>.<span class="at">clientY</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" title="4">    pos3 <span class="op">=</span> <span class="va">e</span>.<span class="at">clientX</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-5" title="5">    pos4 <span class="op">=</span> <span class="va">e</span>.<span class="at">clientY</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="va">console</span>.<span class="at">log</span>(pos1<span class="op">,</span> pos2<span class="op">,</span> pos3<span class="op">,</span> pos4)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="va">terrariumElement</span>.<span class="va">style</span>.<span class="at">top</span> <span class="op">=</span> <span class="va">terrariumElement</span>.<span class="at">offsetTop</span> <span class="op">-</span> pos2 <span class="op">+</span> <span class="st">&#39;px&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="va">terrariumElement</span>.<span class="va">style</span>.<span class="at">left</span> <span class="op">=</span> <span class="va">terrariumElement</span>.<span class="at">offsetLeft</span> <span class="op">-</span> pos1 <span class="op">+</span> <span class="st">&#39;px&#39;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-9" title="9"><span class="op">}</span></a></code></pre></div>
<p>이 함수에서는, 외부 함수에서 로컬 변수로 설정한 초기 위치 1-4를 많이 편집합니다. 여기서 어떤 일이 일어나고 있습니까?</p>
<p>드래그할 때, <code>pos1</code>을 현재 <code>e.clientX</code> 값을 뺀 <code>pos3</code>(이전에<code>e.clientX</code>로 설정)과 동일하게 만들어 <code>pos1</code>을 다시 할당합니다. <code>pos2</code>와 유사한 작업을 수행합니다. 그런 뒤에, <code>pos3</code>과 <code>pos4</code>를 요소의 새로운 X 와 Y 좌표로 다시 설정합니다. 드래그하면 콘솔에서 변경 사항을 볼 수 있습니다. 그런 뒤에, 식물의 css 스타일을 조작하여 <code>pos1</code>과 <code>pos2</code>의 새로운 위치를 기반으로 위치를 설정하고, 오프셋을 이러한 새 위치와 비교하여 식물의 위쪽과 왼쪽 XY 좌표를 계산합니다.</p>
<blockquote>
<p><code>offsetTop</code>과 <code>offsetLeft</code>는 상위 위치를 기준으로 요소의 위치를 설정하는 CSS 속성입니다. 상위는 <code>static</code>으로 두지 않은 모든 요소가 될 수 있습니다.</p>
</blockquote>
<p>모든 위치 다시 계산하며 terrarium과 그 식물의 움직임을 미세하세 조정할 수 있습니다.</p>
<h3 id="작업-5">작업</h3>
<p>인터페이스를 완성하기 위한 마지막 작업은 <code>elementDrag</code>의 닫는 중괄호 뒤에 <code>closeElementDrag</code> 함수를 추가하는 것입니다:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">function</span> <span class="at">stopElementDrag</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="va">document</span>.<span class="at">onpointerup</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="va">document</span>.<span class="at">onpointermove</span> <span class="op">=</span> <span class="kw">null</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="op">}</span></a></code></pre></div>
<p>이 작은 함수는 <code>onpointerup</code>과 <code>onpointermove</code> 이벤트를 다시 설정하므로 다시 드래그하여 식물의 진행 상황을 다시 시작하거나, 새 식물을 드래그할 수 있습니다.</p>
<p>✅ 이러한 이벤트를 null로 설정하지 않으면 어떻게 될까요?</p>
<p>이제 프로젝트를 완료했습니다!</p>
<p>🥇 축하합니다! 아름다운 terrarium을 완성했습니다. <img src=".././images/terrarium-final.png" alt="finished terrarium" /></p>
<hr />
<h2 id="도전">🚀 도전</h2>
<p>클로저에 새로운 이벤트 핸들러를 추가하여 식물에 더 많은 일을 시킵니다. 예를 들어, 식물을 더블 클릭하여 앞으로 가져옵니다. 창의력을 발휘하십시오!</p>
<h2 id="강의-후-퀴즈">강의 후 퀴즈</h2>
<p><a href="https://nice-beach-0fe9e9d0f.azurestaticapps.net/quiz/20?loc=ko">Post-lecture quiz</a></p>
<h2 id="리뷰-자기주도-학습">리뷰 &amp; 자기주도 학습</h2>
<p>화면에서 요소를 드래그하는 것은 사소한 것처럼 보이지만, 원하는 효과에 따라 여러 가지 방식과 함정이 있습니다. 실제로, 시도할 수 있는 전체 <a href="https://developer.mozilla.org/docs/Web/API/HTML_Drag_and_Drop_API">drag and drop API</a>가 있습니다. 우리가 원하는 효과가 다소 다르기 때문에 이 모듈에서는 사용하지 않았지만, 그러나 이 API를 자신의 프로젝트에서 시도해보고 얻을 수 있는 게 무엇인지 확인하시기 바랍니다.</p>
<p>포인터 이벤트에 대한 자세한 내용은 <a href="https://www.w3.org/TR/pointerevents1/">W3C docs</a>와 <a href="https://developer.mozilla.org/docs/Web/API/Pointer_events">MDN web docs</a>에서 확인하세요.</p>
<p>항상 <a href="https://caniuse.com/">CanIUse.com</a>으로 브라우저 기능을 확인하십시오.</p>
<h2 id="과제">과제</h2>
<p><a href="../assignment.md">Work a bit more with the DOM</a></p>
</body>
</html>
