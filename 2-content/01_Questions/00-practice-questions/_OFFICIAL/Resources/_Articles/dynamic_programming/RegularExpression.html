<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>RegularExpression</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="regular-expression---dynamic-programming">Regular Expression - Dynamic Programming</h1>
<p><strong>Translator: <a href="https://github.com/PaperJets">PaperJets</a></strong></p>
<p><strong>Author: <a href="https://github.com/labuladong">labuladong</a></strong></p>
<p>The previous article, “Dynamic Programming in Detail,” was very well-received. Today, I’m going to talk about a practical application: Regular Expression. I highly recommend you to take a look at the previous article, if you don’t know what is “Dynamic Programming”.</p>
<p>Regular Expression is an ingenious algorithm but is a little bit hard to understand. This article mainly focuses on the implementation of two Regular Expression symbols: period「.」and asterisk「*」. Don’t worry if you have never used Regular Expression; I will introduce it later. At the end of this article, I’ll share with you a tip to quickly find the overlapping subproblems.</p>
<p>Another important purpose of this article is to teach readers how to design their own algorithms. Sometimes it’s hard to understand others’ comprehensive algorithms. And we even feel exhausted. But in this article, I just want to tell you that designing an algorithm is not a piece of cake; instead, it’s a continuing upward spiral of progress. You need to work for it, refine it and perfect it. I’ll try my best to make you know how do we simplify problems and build the final solutions from the simplest framework.</p>
<p>Without wasting time, let’s dive into it:</p>
<p>Given a string(s) and a string mode(p). Implement the Regular Expression that supports the ‘.’ and ’*’ match.</p>
<pre><code>
&#39;.&#39;  matches any single character
&#39;*&#39;  matches zero or more before &quot;*&quot;
Note: Matches should cover the whole string, not part of it.</code></pre>
<p>Demo1:</p>
<pre class="text"><code>Input:
  s = &quot;aa&quot;
  p = &quot;a*&quot;
Output:
  true
Explanation:
  &#39;*&#39; represents matching zero or more characters before the &quot;*&quot;. 
  &quot;a*&quot; can either match &quot;a&quot; or &quot;aa&quot;.</code></pre>
<p>Demo2:</p>
<pre class="text"><code>Input:
  s = &quot;aab&quot;
  p = &quot;c*a*b&quot;
Output:
  true
Explanation:
    &#39;c&#39; and &#39;a&#39; can appear zero time or more than one times.</code></pre>
<p>Demo3:</p>
<pre class="text"><code>Input:
    s = &quot;ab&quot;
    p = &quot;.*&quot;
Output:
    true
Explanation:
    &quot;.*&quot; means matching zero or more(&#39;*&#39;) arbitrary character(&#39;.&#39;).</code></pre>
<h3 id="warm-up">1. Warm-up</h3>
<p>The first step, let’s ignore the regular symbols for a moment. If you’re comparing two normal strings, how do you match them? I think this is an algorithm that anyone can write:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">bool</span> isMatch(string text, string pattern) {</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="cf">if</span> (text.size() != pattern.size()) </a>
<a class="sourceLine" id="cb5-3" title="3">        <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="cf">for</span> (<span class="dt">int</span> j = <span class="dv">0</span>; j &lt; pattern.size(); j++) {</a>
<a class="sourceLine" id="cb5-5" title="5">        <span class="cf">if</span> (pattern[j] != text[j])</a>
<a class="sourceLine" id="cb5-6" title="6">            <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb5-7" title="7">    }</a>
<a class="sourceLine" id="cb5-8" title="8">    <span class="cf">return</span> <span class="kw">true</span>;</a>
<a class="sourceLine" id="cb5-9" title="9">}</a></code></pre></div>
<p>Then, I’m going to tweak the above code a little bit. It’s a little more complicated, but it still means the same thing.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb6-1" title="1"><span class="dt">bool</span> isMatch(string text, string pattern) {</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="dt">int</span> i = <span class="dv">0</span>; <span class="co">// Index position of text</span></a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="dt">int</span> j = <span class="dv">0</span>; <span class="co">// Index position of pattern</span></a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="cf">while</span> (j &lt; pattern.size()) {</a>
<a class="sourceLine" id="cb6-5" title="5">        <span class="cf">if</span> (i &gt;= text.size()) </a>
<a class="sourceLine" id="cb6-6" title="6">            <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb6-7" title="7">        <span class="cf">if</span> (pattern[j++] != text[i++])</a>
<a class="sourceLine" id="cb6-8" title="8">            <span class="cf">return</span> <span class="kw">false</span>;</a>
<a class="sourceLine" id="cb6-9" title="9">    }</a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="co">// Equality means matching is complete</span></a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="cf">return</span> j == text.size();</a>
<a class="sourceLine" id="cb6-12" title="12">}</a></code></pre></div>
<p>The above rewriting is to transform this algorithm into a recursive algorithm (pseudo code) :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">def</span> isMatch(text, pattern) <span class="op">-&gt;</span> <span class="bu">bool</span>:</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="cf">if</span> pattern <span class="kw">is</span> empty: <span class="cf">return</span> (text <span class="kw">is</span> empty?)</a>
<a class="sourceLine" id="cb7-3" title="3">    first_match <span class="op">=</span> (text <span class="kw">not</span> empty) <span class="kw">and</span> pattern[<span class="dv">0</span>] <span class="op">==</span> text[<span class="dv">0</span>]</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="cf">return</span> first_match <span class="kw">and</span> isMatch(text[<span class="dv">1</span>:], pattern[<span class="dv">1</span>:])</a></code></pre></div>
<p>If you can understand this code. Congratulations! your recursion idea is in place. The regular expression algorithm, though a little complicated, is actually based on this recursive code.</p>
<h3 id="handle-the-dot-.-wildcard">2. Handle the dot 「.」 wildcard</h3>
<p>Dot can match any character. Very handy! In fact, it is the simplest with a little modification:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">def</span> isMatch(text, pattern) <span class="op">-&gt;</span> <span class="bu">bool</span>:</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="cf">if</span> <span class="kw">not</span> pattern: <span class="cf">return</span> <span class="kw">not</span> text</a>
<a class="sourceLine" id="cb8-3" title="3">    first_match <span class="op">=</span> <span class="bu">bool</span>(text) <span class="kw">and</span> pattern[<span class="dv">0</span>] <span class="kw">in</span> {text[<span class="dv">0</span>], <span class="st">&#39;.&#39;</span>}</a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="cf">return</span> first_match <span class="kw">and</span> isMatch(text[<span class="dv">1</span>:], pattern[<span class="dv">1</span>:])</a></code></pre></div>
<h3 id="handle-the-wildcard">3. Handle the 「*」 wildcard</h3>
<p>The asterisk wildcard allows the previous character to be repeated any number of times, including zero. How many times? It’s a little hard to say, but don’t worry, we can at least build the framework further:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">def</span> isMatch(text, pattern) <span class="op">-&gt;</span> <span class="bu">bool</span>:</a>
<a class="sourceLine" id="cb9-2" title="2">    <span class="cf">if</span> <span class="kw">not</span> pattern: <span class="cf">return</span> <span class="kw">not</span> text</a>
<a class="sourceLine" id="cb9-3" title="3">    first_match <span class="op">=</span> <span class="bu">bool</span>(text) <span class="kw">and</span> pattern[<span class="dv">0</span>] <span class="kw">in</span> {text[<span class="dv">0</span>], <span class="st">&#39;.&#39;</span>}</a>
<a class="sourceLine" id="cb9-4" title="4">    <span class="cf">if</span> <span class="bu">len</span>(pattern) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> pattern[<span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</a>
<a class="sourceLine" id="cb9-5" title="5">        <span class="co"># find &#39;*&#39; wildcard</span></a>
<a class="sourceLine" id="cb9-6" title="6">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb9-7" title="7">        <span class="cf">return</span> first_match <span class="kw">and</span> isMatch(text[<span class="dv">1</span>:], pattern[<span class="dv">1</span>:])</a></code></pre></div>
<p>How many times does the character before the asterisk have to be repeated? It depends on the computation of a computer. Let’s say, N times. As I’ve said many times before, the trick to writing recursion is to focus on the present issues and leave the rest to the recursion. Here, no matter what N is, there are only two choices: zero matches and one match. So you can do it this way:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" title="1"><span class="cf">if</span> <span class="bu">len</span>(pattern) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> pattern[<span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</a>
<a class="sourceLine" id="cb10-2" title="2">    <span class="cf">return</span> isMatch(text, pattern[<span class="dv">2</span>:]) <span class="kw">or</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb10-3" title="3">            first_match <span class="kw">and</span> isMatch(text[<span class="dv">1</span>:], pattern)</a>
<a class="sourceLine" id="cb10-4" title="4"></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="co"># explanation: </span></a>
<a class="sourceLine" id="cb10-6" title="6">    <span class="co">#if a character is found in combination with &#39;*&#39;,</span></a>
<a class="sourceLine" id="cb10-7" title="7">    <span class="co"># or match the character 0 times, then skip the character and &#39;*&#39;</span></a>
<a class="sourceLine" id="cb10-8" title="8">    <span class="co"># or move the text when the pattern[0] matches the text[0]</span></a></code></pre></div>
<p>As we can see, we keep the 「*」 in the pattern and pushed the text backwards to implement the function of 「<em>」 to match the characters repeatedly for many times. A simple example will illustrate the logic. Suppose ’pattern = a</em>’, ‘text = aaa’, we can draw a picture to see the matching process:</p>
<figure>
<img src="../pictures/regularExpression/regex_example.jpg" alt="example" /><figcaption>example</figcaption>
</figure>
<p>At this point, the regular expression algorithm is almost complete.</p>
<h3 id="dynamic-programming">4. Dynamic Programming</h3>
<p>I chose to use the 「memo」 recursion to lower complexity. With the brute force method, the optimization process is as simple as using two variables I and j to record the current matching position, thus avoiding substring slices, and storing I and j in memos to avoid double counting.</p>
<p>I put the violent solution and the optimized solution together so that you can easily compare. You will find that the optimized solution is nothing more than the violent solution “translated”, add a memo. That’s all!</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" title="1"><span class="co"># Recursion with memo</span></a>
<a class="sourceLine" id="cb11-2" title="2"><span class="kw">def</span> isMatch(text, pattern) <span class="op">-&gt;</span> <span class="bu">bool</span>:</a>
<a class="sourceLine" id="cb11-3" title="3">    memo <span class="op">=</span> <span class="bu">dict</span>() <span class="co"># memo</span></a>
<a class="sourceLine" id="cb11-4" title="4">    <span class="kw">def</span> dp(i, j):</a>
<a class="sourceLine" id="cb11-5" title="5">        <span class="cf">if</span> (i, j) <span class="kw">in</span> memo: <span class="cf">return</span> memo[(i, j)]</a>
<a class="sourceLine" id="cb11-6" title="6">        <span class="cf">if</span> j <span class="op">==</span> <span class="bu">len</span>(pattern): <span class="cf">return</span> i <span class="op">==</span> <span class="bu">len</span>(text)</a>
<a class="sourceLine" id="cb11-7" title="7"></a>
<a class="sourceLine" id="cb11-8" title="8">        first <span class="op">=</span> i <span class="op">&lt;</span> <span class="bu">len</span>(text) <span class="kw">and</span> pattern[j] <span class="kw">in</span> {text[i], <span class="st">&#39;.&#39;</span>}</a>
<a class="sourceLine" id="cb11-9" title="9">        </a>
<a class="sourceLine" id="cb11-10" title="10">        <span class="cf">if</span> j <span class="op">&lt;=</span> <span class="bu">len</span>(pattern) <span class="op">-</span> <span class="dv">2</span> <span class="kw">and</span> pattern[j <span class="op">+</span> <span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</a>
<a class="sourceLine" id="cb11-11" title="11">            ans <span class="op">=</span> dp(i, j <span class="op">+</span> <span class="dv">2</span>) <span class="kw">or</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb11-12" title="12">                    first <span class="kw">and</span> dp(i <span class="op">+</span> <span class="dv">1</span>, j)</a>
<a class="sourceLine" id="cb11-13" title="13">        <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb11-14" title="14">            ans <span class="op">=</span> first <span class="kw">and</span> dp(i <span class="op">+</span> <span class="dv">1</span>, j <span class="op">+</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb11-15" title="15">            </a>
<a class="sourceLine" id="cb11-16" title="16">        memo[(i, j)] <span class="op">=</span> ans</a>
<a class="sourceLine" id="cb11-17" title="17">        <span class="cf">return</span> ans</a>
<a class="sourceLine" id="cb11-18" title="18">    </a>
<a class="sourceLine" id="cb11-19" title="19">    <span class="cf">return</span> dp(<span class="dv">0</span>, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb11-20" title="20"></a>
<a class="sourceLine" id="cb11-21" title="21"><span class="co"># brute force recursive</span></a>
<a class="sourceLine" id="cb11-22" title="22"><span class="kw">def</span> isMatch(text, pattern) <span class="op">-&gt;</span> <span class="bu">bool</span>:</a>
<a class="sourceLine" id="cb11-23" title="23">    <span class="cf">if</span> <span class="kw">not</span> pattern: <span class="cf">return</span> <span class="kw">not</span> text</a>
<a class="sourceLine" id="cb11-24" title="24"></a>
<a class="sourceLine" id="cb11-25" title="25">    first <span class="op">=</span> <span class="bu">bool</span>(text) <span class="kw">and</span> pattern[<span class="dv">0</span>] <span class="kw">in</span> {text[<span class="dv">0</span>], <span class="st">&#39;.&#39;</span>}</a>
<a class="sourceLine" id="cb11-26" title="26"></a>
<a class="sourceLine" id="cb11-27" title="27">    <span class="cf">if</span> <span class="bu">len</span>(pattern) <span class="op">&gt;=</span> <span class="dv">2</span> <span class="kw">and</span> pattern[<span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;*&#39;</span>:</a>
<a class="sourceLine" id="cb11-28" title="28">        <span class="cf">return</span> isMatch(text, pattern[<span class="dv">2</span>:]) <span class="kw">or</span> <span class="op">\</span></a>
<a class="sourceLine" id="cb11-29" title="29">                first <span class="kw">and</span> isMatch(text[<span class="dv">1</span>:], pattern)</a>
<a class="sourceLine" id="cb11-30" title="30">    <span class="cf">else</span>:</a>
<a class="sourceLine" id="cb11-31" title="31">        <span class="cf">return</span> first <span class="kw">and</span> isMatch(text[<span class="dv">1</span>:], pattern[<span class="dv">1</span>:])</a></code></pre></div>
<p><strong>Some readers may ask, how do you know that this problem is a dynamic programming problem, how do you know that there is an overlapping subproblem? It’s not easy to find that!</strong></p>
<p>The clearest way is to answer this question is to assume an input and then draw a recursion tree. And you will definitely find the same node, which is a quantitative analysis. In fact, without so much trouble, let me teach you the qualitative analysis, at a glance can see the “overlapping sub-problem” property.</p>
<p>Taking the simplest Fibonacci sequence for example, we abstract the framework of recursive algorithm:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb12-1" title="1"><span class="kw">def</span> fib(n):</a>
<a class="sourceLine" id="cb12-2" title="2">    fib(n <span class="op">-</span> <span class="dv">1</span>) <span class="co">#1</span></a>
<a class="sourceLine" id="cb12-3" title="3">    fib(n <span class="op">-</span> <span class="dv">2</span>) <span class="co">#2</span></a></code></pre></div>
<p>Look at the frame, how do I get from the original problem f(n) to the sub-problem f(n - 2)? There are two paths, one is f(n) -&gt; #1 -&gt; #1, and the other is f(n) -&gt; #2. The former recurses twice; the latter recurse once. Two different computational paths but all face the same problem, which is called the “overlap subproblem”. It is certain that <strong>as long as you find a repeated path, there must be tens of thousands of such repeated paths, meaning that the huge quantum problem overlaps.</strong></p>
<p>Similarly, for this problem, we still abstract the algorithm framework first:</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode py"><code class="sourceCode python"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">def</span> dp(i, j):</a>
<a class="sourceLine" id="cb13-2" title="2">    dp(i, j <span class="op">+</span> <span class="dv">2</span>)     <span class="co">#1</span></a>
<a class="sourceLine" id="cb13-3" title="3">    dp(i <span class="op">+</span> <span class="dv">1</span>, j)     <span class="co">#2</span></a>
<a class="sourceLine" id="cb13-4" title="4">    dp(i <span class="op">+</span> <span class="dv">1</span>, j <span class="op">+</span> <span class="dv">1</span>) <span class="co">#3</span></a></code></pre></div>
<p>A similar problem is raised. How can we reach the subproblem dp(i, j) from the original problem dp(i + 2, j + 2)? There are at least two paths, one is the dp(i, j) - &gt; # 3 - &gt; # 3, the second is the dp (i, j) - &gt; # 1 - &gt; #2 - &gt; #2. Therefore, there must be overlapping subproblems in this problem, which need the optimization skills of dynamic programming to deal with.</p>
<h3 id="summary">5. Summary</h3>
<p>In this article, you have gained a deep insight into the algorithmic implementation of two common wildcards for regular expressions. In fact, the implementation of the dot 「.」is very simple. The key is that the implementation of the asterisk 「*」 needs to use dynamic programming skills, a little more complex. But it breaks down under our analysis. In addition, you have developed a technique for quickly analyzing the nature of overlapping subproblems, allowing you to quickly determine whether a problem can be solved using dynamic programming.</p>
<p>Reviewing the whole process, you should be able to understand the process of algorithm design: from similar simple problems to the basic framework of the gradual assembly of new logic, eventually become a more complex, sophisticated algorithm. So, you guys don’t be afraid of some more complex algorithm problems. No matter how big the algorithm in your eyes is just a piece of cake.</p>
<p>If this article is helpful to you, welcome to pay attention to my wechat official account <strong>labuladong</strong>, I’m committed to make the algorithm problem more clear ~</p>
</body>
</html>
