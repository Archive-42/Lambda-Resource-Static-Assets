<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>FourKeysKeyboard</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="keys-keyboard">4 Keys Keyboard</h1>
<p><strong>Translator: <a href="https://github.com/upbin">upbin</a></strong></p>
<p><strong>Author: <a href="https://github.com/labuladong">labuladong</a></strong></p>
<p>The problem of <em>4 keys keyboard</em> is very interesting and can broaden one’s horizon. This problem can make you obviously feel that different definitions of dp arrays need completely different logic to think about, and this logic can produce completely different solutions.</p>
<p>We can’t wait to solve this problem:</p>
<p><img src="../pictures/4keyboard/title.png" /></p>
<p>After reading the question, think about how to get the maximum number of characters ‘A’ after typing <code>N</code> times on the keyboard? We are more familiar with trying questions using enumeration. Whenever we want to press the keyboard (and can press it), there are <code>4 buttons</code> for us to choose from, we can enumerate every possible operation It is obvious that this is a dynamic programming problem.</p>
<h3 id="discuss-the-first-method">Discuss the first method</h3>
<p>This kind of problem-solving idea is easy to understand, but the efficiency is not high. We follow the routine directly: <strong>for dynamic programming problems, we must first understand which are [ states ] and which are [ choices ].</strong></p>
<p>Specific to this problem, what <strong>choices</strong> are obvious for each keystroke: four types are the <strong>4</strong> keys mentioned in the title, which are <code>A</code> , <code>Ctrl-A</code> , <code>Ctrl-C</code> , and <code>Ctrl-V</code> .</p>
<p>Next, let’s think about what are the <strong>states</strong> of this problem? <strong>In other words, what information do we need to know to break down the original problem into smaller subproblems?</strong></p>
<p>Now you think about it, Is it correct for me to define the status of this problem as follows?</p>
<ul>
<li>The first state is the remaining number of times the key can be pressed, we use <code>n</code> to represent it.</li>
<li>The second state is the number of characters ‘A’ on the current screen, we use <code>a_num</code>.</li>
<li>The third state is the number of characters ‘A’ still in the clipboard, represented by <code>copy</code>.</li>
</ul>
<p>By defining <strong>state</strong> in this way, we can know the <em>base case</em>: when the number of remaining <code>n</code> is <code>0</code> , <code>a_num</code> is the answer we want.</p>
<p>Combining the four <strong>choices</strong> just mentioned, we can express these kinds of choices through state transitions:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">dp(n <span class="op">-</span> <span class="dv">1</span>, a_num <span class="op">+</span> <span class="dv">1</span>, copy)        <span class="co"># [ A ]</span></a>
<a class="sourceLine" id="cb1-2" title="2"><span class="co"># comment: Press the &#39;A&#39; key to add a character to the screen.</span></a>
<a class="sourceLine" id="cb1-3" title="3"><span class="co"># Subtract 1 at the same time the number of times you are allowed to press the keyboard.</span></a>
<a class="sourceLine" id="cb1-4" title="4"></a>
<a class="sourceLine" id="cb1-5" title="5">dp(n <span class="op">-</span> <span class="dv">1</span>, a_num <span class="op">+</span> copy, copy)     <span class="co"># [Ctrl-V]</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="co"># comment: Press C-V to paste, the characters in the clipboard are added to the screen.</span></a>
<a class="sourceLine" id="cb1-7" title="7"><span class="co"># Subtract 1 at the same time the number of times you are allowed to press the keyboard.</span></a>
<a class="sourceLine" id="cb1-8" title="8"></a>
<a class="sourceLine" id="cb1-9" title="9">dp(n <span class="op">-</span> <span class="dv">2</span>, a_num, a_num)           <span class="co"># [Ctrl-A] &amp; [Ctrl-C]</span></a>
<a class="sourceLine" id="cb1-10" title="10"><span class="co"># comment: Ctrl + A and Ctrl + C can obviously be used together.</span></a>
<a class="sourceLine" id="cb1-11" title="11"><span class="co"># The number of &#39;A&#39; in the clipboard becomes the number of &#39;A&#39; on the screen.</span></a>
<a class="sourceLine" id="cb1-12" title="12"><span class="co"># Subtract 2 at the same time the number of times you are allowed to press the keyboard.</span></a></code></pre></div>
<p>By describing this, we can see that the scale of the problem <code>n</code> is constantly decreasing, and finally we can reach the <em>base case</em> of <code>n == 0</code> . So this idea is correct: (Do you think so?)</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">def</span> maxA(N: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</a>
<a class="sourceLine" id="cb2-2" title="2">    </a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="co"># It can be verified that for the initial (n, a_num, copy) state,</span></a>
<a class="sourceLine" id="cb2-4" title="4">    <span class="co"># there can be at most dp (n, a_num, copy) &#39;A&#39; on the screen.</span></a>
<a class="sourceLine" id="cb2-5" title="5">    <span class="kw">def</span> dp(n, a_num, copy):</a>
<a class="sourceLine" id="cb2-6" title="6">        <span class="co"># base case</span></a>
<a class="sourceLine" id="cb2-7" title="7">        <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">0</span>: <span class="cf">return</span> a_num<span class="op">;</span></a>
<a class="sourceLine" id="cb2-8" title="8">        <span class="co"># Let &#39;s try all three options and choose the largest one.</span></a>
<a class="sourceLine" id="cb2-9" title="9">        <span class="cf">return</span> <span class="bu">max</span>(</a>
<a class="sourceLine" id="cb2-10" title="10">                dp(n <span class="op">-</span> <span class="dv">1</span>, a_num <span class="op">+</span> <span class="dv">1</span>, copy),    <span class="co"># [ A ]</span></a>
<a class="sourceLine" id="cb2-11" title="11">                dp(n <span class="op">-</span> <span class="dv">1</span>, a_num <span class="op">+</span> copy, copy), <span class="co"># [Ctrl-V]</span></a>
<a class="sourceLine" id="cb2-12" title="12">                dp(n <span class="op">-</span> <span class="dv">2</span>, a_num, a_num)        <span class="co"># [Ctrl-A] &amp; [Ctrl-C]</span></a>
<a class="sourceLine" id="cb2-13" title="13">            )</a>
<a class="sourceLine" id="cb2-14" title="14"></a>
<a class="sourceLine" id="cb2-15" title="15">    <span class="co"># You can press the key n times, then there is no &#39;A&#39; in the screen</span></a>
<a class="sourceLine" id="cb2-16" title="16">    <span class="co"># and the clipboard.</span></a>
<a class="sourceLine" id="cb2-17" title="17">    <span class="cf">return</span> dp(N, <span class="dv">0</span>, <span class="dv">0</span>)</a></code></pre></div>
<p>This solution should be well understood because it is semantically explicit.</p>
<p>Below we continue to follow the routine and use <u>memorized search</u> to eliminate those overlapping sub-problems:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">def</span> maxA(N: <span class="bu">int</span>) <span class="op">-&gt;</span> <span class="bu">int</span>:</a>
<a class="sourceLine" id="cb3-2" title="2">    <span class="co"># memorandum</span></a>
<a class="sourceLine" id="cb3-3" title="3">    memo <span class="op">=</span> <span class="bu">dict</span>()</a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="kw">def</span> dp(n, a_num, copy):</a>
<a class="sourceLine" id="cb3-5" title="5">        <span class="cf">if</span> n <span class="op">&lt;=</span> <span class="dv">0</span>: <span class="cf">return</span> a_num<span class="op">;</span></a>
<a class="sourceLine" id="cb3-6" title="6">        <span class="co"># Avoid overlapping subproblems being recalculated</span></a>
<a class="sourceLine" id="cb3-7" title="7">        <span class="cf">if</span> (n, a_num, copy) <span class="kw">in</span> memo:</a>
<a class="sourceLine" id="cb3-8" title="8">            <span class="cf">return</span> memo[(n, a_num, copy)]</a>
<a class="sourceLine" id="cb3-9" title="9"></a>
<a class="sourceLine" id="cb3-10" title="10">        memo[(n, a_num, copy)] <span class="op">=</span> <span class="bu">max</span>(</a>
<a class="sourceLine" id="cb3-11" title="11">                <span class="co"># These options are still the same</span></a>
<a class="sourceLine" id="cb3-12" title="12">            )</a>
<a class="sourceLine" id="cb3-13" title="13">        <span class="cf">return</span> memo[(n, a_num, copy)]</a>
<a class="sourceLine" id="cb3-14" title="14"></a>
<a class="sourceLine" id="cb3-15" title="15">    <span class="cf">return</span> dp(N, <span class="dv">0</span>, <span class="dv">0</span>)</a></code></pre></div>
<p>After we optimized our code in this way, although the sub-problem was repeatedly solved, the number of searches was still very large (<em>if we submit to LeetCode it will definitely time out</em>).</p>
<p>Now let’s try to analyze the time complexity of the algorithm just now. The challenge is that this analysis is not easy. No matter what it is, now we write this <em>dp function</em> as a <em>dp array</em>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode cpp"><code class="sourceCode cpp"><a class="sourceLine" id="cb4-1" title="1">dp[n][a_num][copy]</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="co">// The total number of states (spatial complexity) of this problem</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co">// is the volume of this three-dimensional array.</span></a></code></pre></div>
<p>We know that the maximum value of the variable <code>n</code> is <code>N</code>, but it is difficult to calculate the maximum number of <code>a_num</code> and <code>copy</code>. The lowest complexity is <em>O(N^3)​</em>. So the algorithm just now is not good, the complexity is too high, and it can no longer be optimized.</p>
<p>The more embarrassing thing is that this also shows that I used to define <strong>state</strong> as it is not very good. Let’s change the idea of defining this dp problem.</p>
<h3 id="exploration-of-the-second-approach">Exploration of the second approach</h3>
<p>Next, our thinking is a little more complicated, but it is very efficient.</p>
<p>Continue to follow our routine, <strong>choice</strong> has been defined before, or the <code>4</code>. But this time we only need to define <strong>a state</strong>, which is the remaining number of available keyboard presses <code>n</code>.</p>
<p>This algorithm is based on the following fact. There must be only two cases of the key sequence corresponding to the optimal answer:</p>
<ul>
<li>Either keep pressing A: <code>A</code>, <code>A</code>, … , <code>A</code> (more when <code>N</code> is smaller).</li>
<li>Either this is the form: <code>A</code>, <code>A</code>, …, <code>Ctrl-A</code>, <code>Ctrl-C</code>, <code>Ctrl-V</code>, <code>Ctrl-V</code>, …, <code>Ctrl-V</code> (mostly when <code>N</code> is larger). <em>(Here you can find some mathematical rules, you can study if you are interested)</em></li>
</ul>
<p>Because when the number of characters to be printed is relatively small (<code>N</code> is small), “<code>Ctrl-A</code>, <code>Ctrl-C</code>, <code>Ctrl-V</code>” consumes a relatively high number of operations, so we might as well keep pressing <code>A</code>. When <code>N</code> is relatively large, the gain of <code>Ctrl-V</code> in the later period is definitely relatively large. In this case, the entire operation sequence is roughly like this: at the beginning, press several ’A’s, then <code>Ctrl-A</code>, <code>Ctrl-C</code>, and finally several <code>Ctrl-V</code>, and then continue <code>Ctrl-A -&gt; Ctrl-C -&gt; Ctrl-V</code> Such a loop operation.</p>
<p>In other words, the last keystroke was either <code>A</code> or <code>Ctrl-V</code>. As long as we are clear on this, we can design the algorithm through these <strong>two situations</strong>:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">int</span>[] dp = <span class="kw">new</span> <span class="dt">int</span>[N + <span class="dv">1</span>];</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="co">// Definition: dp[i] indicates the maximum number of &#39;A&#39; that can be displayed after the // first operation.</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= N; i++) </a>
<a class="sourceLine" id="cb5-4" title="4">    dp[i] = <span class="fu">max</span>(</a>
<a class="sourceLine" id="cb5-5" title="5">        <span class="co">// Press [ A ] this time,</span></a>
<a class="sourceLine" id="cb5-6" title="6">          <span class="co">// This time press [Ctrl-V].</span></a>
<a class="sourceLine" id="cb5-7" title="7">        )</a></code></pre></div>
<p>Think about it. For the case of [pressing the <code>A</code> key], it is actually a new ‘A’ printed on the screen of <strong>state i-1</strong>, so it is easy to get the result:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb6-1" title="1"><span class="co">// If we press the [ A ] key, it&#39;s just one more &#39;A&#39; than the last time.</span></a>
<a class="sourceLine" id="cb6-2" title="2">dp[i] = dp[i - <span class="dv">1</span>] + <span class="dv">1</span>;</a></code></pre></div>
<p>However, if we want to press <code>Ctrl-V</code> , we also need to consider where we did <code>Ctrl-A</code> and <code>Ctrl-C</code> .</p>
<p>Earlier we said that the optimal sequence of operations must be <code>Ctrl-A</code> , <code>Ctrl-C</code> followed by several <code>Ctrl-V</code> , so we use a variable <code>j</code> as the starting point for these <code>Ctrl-V</code> operations. Then the two operations before <code>j</code> should be <code>Ctrl-A</code> and <code>Ctrl-C</code> :</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">public</span> <span class="dt">int</span> <span class="fu">maxA</span>(<span class="dt">int</span> N) {</a>
<a class="sourceLine" id="cb7-2" title="2">    <span class="dt">int</span>[] dp = <span class="kw">new</span> <span class="dt">int</span>[N + <span class="dv">1</span>];</a>
<a class="sourceLine" id="cb7-3" title="3">    dp[<span class="dv">0</span>] = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">1</span>; i &lt;= N; i++) {</a>
<a class="sourceLine" id="cb7-5" title="5">        <span class="co">// press [ A ]</span></a>
<a class="sourceLine" id="cb7-6" title="6">        dp[i] = dp[i - <span class="dv">1</span>] + <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb7-7" title="7">        <span class="kw">for</span> (<span class="dt">int</span> j = <span class="dv">2</span>; j &lt; i; j++) {</a>
<a class="sourceLine" id="cb7-8" title="8">            <span class="co">// [Ctrl-A] &amp; [Ctrl-C] -&gt; dp[j-2], Paste i-j times</span></a>
<a class="sourceLine" id="cb7-9" title="9">            <span class="co">// There are { dp[j-2] * (i-j+1) }number of &#39;A&#39; on the screen</span></a>
<a class="sourceLine" id="cb7-10" title="10">            dp[i] = <span class="bu">Math</span>.<span class="fu">max</span>(dp[i], dp[j - <span class="dv">2</span>] * (i - j + <span class="dv">1</span>));</a>
<a class="sourceLine" id="cb7-11" title="11">        }</a>
<a class="sourceLine" id="cb7-12" title="12">    }</a>
<a class="sourceLine" id="cb7-13" title="13">    <span class="co">// What is the maximum number of &#39;A&#39; after N keystrokes?</span></a>
<a class="sourceLine" id="cb7-14" title="14">    <span class="kw">return</span> dp[N];</a>
<a class="sourceLine" id="cb7-15" title="15">}</a></code></pre></div>
<p>The <code>j</code> variable <code>minus 2</code> is used to save the number of operations available to <code>Ctrl-A</code> , <code>Ctrl-C</code> . See the description picture to understand:</p>
<p><img src="../pictures/4keyboard/1.jpg" /></p>
<p>We have just completed this algorithm. The time complexity of the algorithm is <em>O(N^2)​</em> and the space complexity is ​<em>O(N)</em>​, so this solution seems to be very efficient.</p>
<h3 id="review-our-algorithmic-ideas">Review our algorithmic ideas</h3>
<p>Dynamic programming is difficult to find the state transition. The different definitions we set will produce different state transition logic. Although we can all get the correct results in the end, the efficiency of the program may have amazing differences.</p>
<p>Let’s review the method we tried for the first time. Although the overlapping sub-problem has been eliminated, the efficiency of the program is still low, but where is the low? Let’s abstract the recursive framework to find out:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">def</span> dp(n, a_num, copy):</a>
<a class="sourceLine" id="cb8-2" title="2">    dp(n <span class="op">-</span> <span class="dv">1</span>, a_num <span class="op">+</span> <span class="dv">1</span>, copy),    <span class="co"># [ A ]</span></a>
<a class="sourceLine" id="cb8-3" title="3">    dp(n <span class="op">-</span> <span class="dv">1</span>, a_num <span class="op">+</span> copy, copy), <span class="co"># [Ctrl-V]</span></a>
<a class="sourceLine" id="cb8-4" title="4">    dp(n <span class="op">-</span> <span class="dv">2</span>, a_num, a_num)        <span class="co"># [Ctrl-A] &amp; [Ctrl-C]</span></a></code></pre></div>
<p>Let’s analyze the logic of this exhaustive scheme. Obviously, it is possible to have such a sequence of operations <code>Ctrl-A</code> , <code>Ctrl+C</code> , <code>Ctrl-A</code> , <code>Ctrl-C</code> , … , or <code>Ctrl-V</code> , <code>Ctrl-V</code> , … . However, the result of the operation sequence produced by this method is not optimal, even if we have not figured out a way to circumvent these situations, thereby adding a lot of calculations of unnecessary sub-problems.</p>
<p>After we review the second solution, we only need to think a little bit before we can think that the operation sequence of the optimal answer should be this form: <code>A</code> , <code>A</code> , …, <code>Ctrl-A</code> , <code>Ctrl-C</code> , <code>Ctrl-V</code> , <code>Ctrl-V</code> , …, <code>Ctrl-V</code> .</p>
<p>Based on the findings we found, we redefined <u>state</u> and re-searched for <u>state transition</u>, which logically reduced the number of invalid sub-problems, and ultimately optimized the program’s operating efficiency.</p>
</body>
</html>
