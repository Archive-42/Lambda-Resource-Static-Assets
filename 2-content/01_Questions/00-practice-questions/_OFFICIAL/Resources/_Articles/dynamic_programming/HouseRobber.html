<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>HouseRobber</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<p>add# House Robber series</p>
<p><strong>Translator</strong>: <a href="https://github.com/xiaochuhub">cooker</a></p>
<p><strong>Author</strong>: <a href="https://github.com/labuladong">labuladong</a></p>
<p>I find that this series of problems are highly praised. They are representative and skillful dynamic planning problems. Today I will introduce an generalized method to solve all of these problems.</p>
<p>House robber series includes three problems. The difficulty design is very reasonable and progressive. The first (<a href="https://leetcode.com/problems/house-robber/">house robber</a>) is a standard dynamic programming problem.</p>
<p>The second (<a href="https://leetcode.com/problems/house-robber-ii/">house robber ii</a>) include incorporates the condition of a circular array.</p>
<p>The third (<a href="https://leetcode.com/problems/house-robber-iii/">house robber iii</a>) is quite amazing which combines the bottom-up and top-down solutions of dynamic programming with a binary tree. If you haven’t done it, I highly recommend this series of problems.</p>
<h3 id="house-robber-i">House Robber I</h3>
<figure>
<img src="../pictures/robber/rob1.jpg" alt="title" /><figcaption>title</figcaption>
</figure>
<div class="sourceCode" id="cb1"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">public</span> <span class="dt">int</span> <span class="fu">rob</span>(<span class="dt">int</span>[] nums);</a></code></pre></div>
<p>The problem is easy to understand and the characteristics of dynamic programming are quite obvious. We have summarized the [Dynamic programming Detailed Explanation] before, <strong>the key points to solve the dynamic programming problem is to find [state] and [choice]</strong>.</p>
<p>Imagine that you are this professional robber. You walk through this row of houses from left to right. There are two <strong>choices</strong> in front of each house: <code>rob</code> or <code>not rob</code> .</p>
<p><code>rob</code> : If you rob this house, then you <strong>definitely</strong> can’t rob the adjacent houses, you can only start the next rob from the house after next.</p>
<p><code>not rob</code> : If you don’t rob this house, then you can walk to the next house and continue making choices.</p>
<p>When you walked past the last house, you don’t have to rob. The money you could rob is obviously 0 (<strong>base case</strong>).</p>
<p>The above logic is very simple. In fact, the <strong>state</strong> and <strong>choice</strong> have been clearly defined: <strong>The index of the house in front of you is the <code>state</code> , and rob or not rob is <code>choice</code> </strong>.</p>
<figure>
<img src="../pictures/robber/1.jpg" alt="1" /><figcaption>1</figcaption>
</figure>
<p>In these two choices, you need to choose a larger result each time. You end up with the most money you can rob:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb2-1" title="1"><span class="co">// main function</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">public</span> <span class="dt">int</span> <span class="fu">rob</span>(<span class="dt">int</span>[] nums) {</a>
<a class="sourceLine" id="cb2-3" title="3">    <span class="kw">return</span> <span class="fu">dp</span>(nums, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb2-4" title="4">}</a>
<a class="sourceLine" id="cb2-5" title="5"><span class="co">// return nums[start..] Maximum value that can be robbed</span></a>
<a class="sourceLine" id="cb2-6" title="6"><span class="kw">private</span> <span class="dt">int</span> <span class="fu">dp</span>(<span class="dt">int</span>[] nums, <span class="dt">int</span> start) {</a>
<a class="sourceLine" id="cb2-7" title="7">    <span class="kw">if</span> (start &gt;= nums.<span class="fu">length</span>) {</a>
<a class="sourceLine" id="cb2-8" title="8">        <span class="kw">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb2-9" title="9">    }</a>
<a class="sourceLine" id="cb2-10" title="10">    </a>
<a class="sourceLine" id="cb2-11" title="11">    <span class="dt">int</span> res = <span class="bu">Math</span>.<span class="fu">max</span>(</a>
<a class="sourceLine" id="cb2-12" title="12">            <span class="co">// not rob, walk to the next house</span></a>
<a class="sourceLine" id="cb2-13" title="13">            <span class="fu">dp</span>(nums, start + <span class="dv">1</span>), </a>
<a class="sourceLine" id="cb2-14" title="14">            <span class="co">// rob，walk to the house after next</span></a>
<a class="sourceLine" id="cb2-15" title="15">            nums[start] + <span class="fu">dp</span>(nums, start + <span class="dv">2</span>)</a>
<a class="sourceLine" id="cb2-16" title="16">        );</a>
<a class="sourceLine" id="cb2-17" title="17">    <span class="kw">return</span> res;</a>
<a class="sourceLine" id="cb2-18" title="18">}</a></code></pre></div>
<p>After clearing the state transition, we can find that there is an overlap sub-problem for the same <code>start</code> position, such as the following figure:</p>
<figure>
<img src="../pictures/robber/2.jpg" alt="2" /><figcaption>2</figcaption>
</figure>
<p>Thieves have multiple choices to go to this position. Wouldn’t it be a waste of time if they entered recursion every time? So there are overlapping sub-problems that can be optimized with memos:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">private</span> <span class="dt">int</span>[] memo;</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="co">// main function</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">public</span> <span class="dt">int</span> <span class="fu">rob</span>(<span class="dt">int</span>[] nums) {</a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="co">// initialize the memos</span></a>
<a class="sourceLine" id="cb3-5" title="5">    memo = <span class="kw">new</span> <span class="dt">int</span>[nums.<span class="fu">length</span>];</a>
<a class="sourceLine" id="cb3-6" title="6">    <span class="bu">Arrays</span>.<span class="fu">fill</span>(memo, -<span class="dv">1</span>);</a>
<a class="sourceLine" id="cb3-7" title="7">    <span class="co">// robber robs from house 0</span></a>
<a class="sourceLine" id="cb3-8" title="8">    <span class="kw">return</span> <span class="fu">dp</span>(nums, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb3-9" title="9">}</a>
<a class="sourceLine" id="cb3-10" title="10"></a>
<a class="sourceLine" id="cb3-11" title="11"><span class="co">// return dp[start..] Maximum value that can be robbed</span></a>
<a class="sourceLine" id="cb3-12" title="12"><span class="kw">private</span> <span class="dt">int</span> <span class="fu">dp</span>(<span class="dt">int</span>[] nums, <span class="dt">int</span> start) {</a>
<a class="sourceLine" id="cb3-13" title="13">    <span class="kw">if</span> (start &gt;= nums.<span class="fu">length</span>) {</a>
<a class="sourceLine" id="cb3-14" title="14">        <span class="kw">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb3-15" title="15">    }</a>
<a class="sourceLine" id="cb3-16" title="16">    <span class="co">// Avoid duplicate processing</span></a>
<a class="sourceLine" id="cb3-17" title="17">    <span class="kw">if</span> (memo[start] != -<span class="dv">1</span>) <span class="kw">return</span> memo[start];</a>
<a class="sourceLine" id="cb3-18" title="18">    </a>
<a class="sourceLine" id="cb3-19" title="19">    <span class="dt">int</span> res = <span class="bu">Math</span>.<span class="fu">max</span>(<span class="fu">dp</span>(nums, start + <span class="dv">1</span>), </a>
<a class="sourceLine" id="cb3-20" title="20">                    nums[start] + <span class="fu">dp</span>(nums, start + <span class="dv">2</span>));</a>
<a class="sourceLine" id="cb3-21" title="21">    <span class="co">// record the result to memos</span></a>
<a class="sourceLine" id="cb3-22" title="22">    memo[start] = res;</a>
<a class="sourceLine" id="cb3-23" title="23">    <span class="kw">return</span> res;</a>
<a class="sourceLine" id="cb3-24" title="24">}</a></code></pre></div>
<p>This is the top-down dynamic programming solution. We can also modify it slightly and write the <strong>bottom-up</strong> solution:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb4-1" title="1"> <span class="dt">int</span> <span class="fu">rob</span>(<span class="dt">int</span>[] nums) {</a>
<a class="sourceLine" id="cb4-2" title="2">    <span class="dt">int</span> n = nums.<span class="fu">length</span>;</a>
<a class="sourceLine" id="cb4-3" title="3">    <span class="co">// dp[i] = x: start rob at i-th house, the maximum money you can get is x</span></a>
<a class="sourceLine" id="cb4-4" title="4">    <span class="co">// base case: dp[n] = 0</span></a>
<a class="sourceLine" id="cb4-5" title="5">    <span class="dt">int</span>[] dp = <span class="kw">new</span> <span class="dt">int</span>[n + <span class="dv">2</span>];</a>
<a class="sourceLine" id="cb4-6" title="6">    <span class="kw">for</span> (<span class="dt">int</span> i = n - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i--) {</a>
<a class="sourceLine" id="cb4-7" title="7">        dp[i] = <span class="bu">Math</span>.<span class="fu">max</span>(dp[i + <span class="dv">1</span>], nums[i] + dp[i + <span class="dv">2</span>]);</a>
<a class="sourceLine" id="cb4-8" title="8">    }</a>
<a class="sourceLine" id="cb4-9" title="9">    <span class="kw">return</span> dp[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb4-10" title="10">}</a></code></pre></div>
<p>We also found that the state transition is only related to the two recent states of <code>dp [i]</code> , so it can be further optimized to reduce the space complexity to O(1).</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb5-1" title="1"><span class="dt">int</span> <span class="fu">rob</span>(<span class="dt">int</span>[] nums) {</a>
<a class="sourceLine" id="cb5-2" title="2">    <span class="dt">int</span> n = nums.<span class="fu">length</span>;</a>
<a class="sourceLine" id="cb5-3" title="3">    <span class="co">// record dp[i+1] and dp[i+2]</span></a>
<a class="sourceLine" id="cb5-4" title="4">    <span class="dt">int</span> dp_i_<span class="dv">1</span> = <span class="dv">0</span>, dp_i_<span class="dv">2</span> = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb5-5" title="5">    <span class="co">// record dp[i]</span></a>
<a class="sourceLine" id="cb5-6" title="6">    <span class="dt">int</span> dp_i = <span class="dv">0</span>; </a>
<a class="sourceLine" id="cb5-7" title="7">    <span class="kw">for</span> (<span class="dt">int</span> i = n - <span class="dv">1</span>; i &gt;= <span class="dv">0</span>; i--) {</a>
<a class="sourceLine" id="cb5-8" title="8">        dp_i = <span class="bu">Math</span>.<span class="fu">max</span>(dp_i_<span class="dv">1</span>, nums[i] + dp_i_<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb5-9" title="9">        dp_i_<span class="dv">2</span> = dp_i_<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb5-10" title="10">        dp_i_<span class="dv">1</span> = dp_i;</a>
<a class="sourceLine" id="cb5-11" title="11">    }</a>
<a class="sourceLine" id="cb5-12" title="12">    <span class="kw">return</span> dp_i;</a>
<a class="sourceLine" id="cb5-13" title="13">}</a></code></pre></div>
<p>The above process has been explained in detail in [Dynamic programming Detailed Explanation]. I believe that everyone can catch it. I think the next problem is more interesting, and we need to make some clever changes based on our current thinking.</p>
<h3 id="house-robber-ii">House Robber II</h3>
<figure>
<img src="../pictures/robber/rob2.jpg" alt="title" /><figcaption>title</figcaption>
</figure>
<p>This question is basically the same as the first description. The robber still cannot rob adjacent houses. The input is still an array, but these houses are not in a row but arranged in a <strong>circle</strong>.</p>
<p>In other words, the first house and the last house are also adjacent and cannot be robbed at the same time. For example, if the input array <code>nums = [2,3,2]</code> , the result returned by the algorithm should be 3 instead of 4, because the beginning and end cann’t be robbed at the same time.</p>
<p>It seems that this constraint should not be difficult to solve. We mentioned a solution for circular arrays in [a monotonic stack solve Next Greater Number]. So how to deal with this problem?</p>
<p>First of all, the first and last rooms cannot be robbed at the same time, then there are only three possible situations: case I, either they are not robbed; case II the first house is robbed and the last one is not robbed; case III, the first house is not robbed and the last one is robbed;</p>
<figure>
<img src="./../pictures/robber/3.jpg" alt="3" /><figcaption>3</figcaption>
</figure>
<p>That’s easy. The solution is the maximum of these three cases. However, in fact, we don’t need to compare three cases, just compare case II and case III. <strong>Because these two cases have more room to choose than the case I, the money in the house is non-negative. So the optimal decision result is certainly not small if we have more choice</strong>.</p>
<p>So just modify the previous solution slightly:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">public</span> <span class="dt">int</span> <span class="fu">rob</span>(<span class="dt">int</span>[] nums) {</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="dt">int</span> n = nums.<span class="fu">length</span>;</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="kw">if</span> (n == <span class="dv">1</span>) <span class="kw">return</span> nums[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb6-4" title="4">    <span class="kw">return</span> <span class="bu">Math</span>.<span class="fu">max</span>(<span class="fu">robRange</span>(nums, <span class="dv">0</span>, n - <span class="dv">2</span>), </a>
<a class="sourceLine" id="cb6-5" title="5">                    <span class="fu">robRange</span>(nums, <span class="dv">1</span>, n - <span class="dv">1</span>));</a>
<a class="sourceLine" id="cb6-6" title="6">}</a>
<a class="sourceLine" id="cb6-7" title="7"></a>
<a class="sourceLine" id="cb6-8" title="8"><span class="co">// Calculate the optimal result for only the closed interval [start, end]</span></a>
<a class="sourceLine" id="cb6-9" title="9"><span class="dt">int</span> <span class="fu">robRange</span>(<span class="dt">int</span>[] nums, <span class="dt">int</span> start, <span class="dt">int</span> end) {</a>
<a class="sourceLine" id="cb6-10" title="10">    <span class="dt">int</span> n = nums.<span class="fu">length</span>;</a>
<a class="sourceLine" id="cb6-11" title="11">    <span class="dt">int</span> dp_i_<span class="dv">1</span> = <span class="dv">0</span>, dp_i_<span class="dv">2</span> = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb6-12" title="12">    <span class="dt">int</span> dp_i = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb6-13" title="13">    <span class="kw">for</span> (<span class="dt">int</span> i = end; i &gt;= start; i--) {</a>
<a class="sourceLine" id="cb6-14" title="14">        dp_i = <span class="bu">Math</span>.<span class="fu">max</span>(dp_i_<span class="dv">1</span>, nums[i] + dp_i_<span class="dv">2</span>);</a>
<a class="sourceLine" id="cb6-15" title="15">        dp_i_<span class="dv">2</span> = dp_i_<span class="dv">1</span>;</a>
<a class="sourceLine" id="cb6-16" title="16">        dp_i_<span class="dv">1</span> = dp_i;</a>
<a class="sourceLine" id="cb6-17" title="17">    }</a>
<a class="sourceLine" id="cb6-18" title="18">    <span class="kw">return</span> dp_i;</a>
<a class="sourceLine" id="cb6-19" title="19">}</a></code></pre></div>
<p>At this point, the second problem has also been solved.</p>
<h3 id="house-robber-iii">House Robber III</h3>
<p>The third question changes the pattern again. The house now is arranged not a row, not a circle, but a binary tree! The house is on the node of the binary tree. The two connected houses cannot be robbed at the same time. It is indeed a legendary high IQ crime:</p>
<figure>
<img src="../pictures/robber/rob3.jpg" alt="title" /><figcaption>title</figcaption>
</figure>
<p>The overall thinking hasn’t changed at all, we need to choose the option of robbing or not robbing, and make choice with higher returns. We can even write the code directly according to this routine:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb7-1" title="1"><span class="bu">Map</span>&lt;<span class="bu">TreeNode</span>, <span class="bu">Integer</span>&gt; memo = <span class="kw">new</span> <span class="bu">HashMap</span>&lt;&gt;();</a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">public</span> <span class="dt">int</span> <span class="fu">rob</span>(<span class="bu">TreeNode</span> root) {</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="kw">if</span> (root == <span class="kw">null</span>) <span class="kw">return</span> <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="co">// Eliminating overlapping subproblems with memos</span></a>
<a class="sourceLine" id="cb7-5" title="5">    <span class="kw">if</span> (memo.<span class="fu">containsKey</span>(root)) </a>
<a class="sourceLine" id="cb7-6" title="6">        <span class="kw">return</span> memo.<span class="fu">get</span>(root);</a>
<a class="sourceLine" id="cb7-7" title="7">    <span class="co">// rob, walk to the house after next</span></a>
<a class="sourceLine" id="cb7-8" title="8">    <span class="dt">int</span> do_it = root.<span class="fu">val</span></a>
<a class="sourceLine" id="cb7-9" title="9"></a>
<a class="sourceLine" id="cb7-10" title="10">        + (root.<span class="fu">left</span> == <span class="kw">null</span> ? </a>
<a class="sourceLine" id="cb7-11" title="11"></a>
<a class="sourceLine" id="cb7-12" title="12">            <span class="dv">0</span> : <span class="fu">rob</span>(root.<span class="fu">left</span>.<span class="fu">left</span>) + <span class="fu">rob</span>(root.<span class="fu">left</span>.<span class="fu">right</span>))</a>
<a class="sourceLine" id="cb7-13" title="13"></a>
<a class="sourceLine" id="cb7-14" title="14">        + (root.<span class="fu">right</span> == <span class="kw">null</span> ? </a>
<a class="sourceLine" id="cb7-15" title="15"></a>
<a class="sourceLine" id="cb7-16" title="16">            <span class="dv">0</span> : <span class="fu">rob</span>(root.<span class="fu">right</span>.<span class="fu">left</span>) + <span class="fu">rob</span>(root.<span class="fu">right</span>.<span class="fu">right</span>));</a>
<a class="sourceLine" id="cb7-17" title="17">    <span class="co">// not rob, walk to the next house</span></a>
<a class="sourceLine" id="cb7-18" title="18">    <span class="dt">int</span> not_do = <span class="fu">rob</span>(root.<span class="fu">left</span>) + <span class="fu">rob</span>(root.<span class="fu">right</span>);</a>
<a class="sourceLine" id="cb7-19" title="19">    </a>
<a class="sourceLine" id="cb7-20" title="20">    <span class="dt">int</span> res = <span class="bu">Math</span>.<span class="fu">max</span>(do_it, not_do);</a>
<a class="sourceLine" id="cb7-21" title="21">    memo.<span class="fu">put</span>(root, res);</a>
<a class="sourceLine" id="cb7-22" title="22">    <span class="kw">return</span> res;</a>
<a class="sourceLine" id="cb7-23" title="23">}</a></code></pre></div>
<p>This problem is solved, the time complexity O (N), <code>N</code> is the number of nodes.</p>
<p>But what makes me think that this problem is clever is that there are more beautiful solutions. For example, here is a solution I saw in the comment:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb8-1" title="1"><span class="dt">int</span> <span class="fu">rob</span>(<span class="bu">TreeNode</span> root) {</a>
<a class="sourceLine" id="cb8-2" title="2">    <span class="dt">int</span>[] res = <span class="fu">dp</span>(root);</a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="kw">return</span> <span class="bu">Math</span>.<span class="fu">max</span>(res[<span class="dv">0</span>], res[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb8-4" title="4">}</a>
<a class="sourceLine" id="cb8-5" title="5"></a>
<a class="sourceLine" id="cb8-6" title="6"><span class="co">/* return an array of size 2 arr</span></a>
<a class="sourceLine" id="cb8-7" title="7"><span class="co">arr [0] means the maximum amount of money you get if you do not rob root</span></a>
<a class="sourceLine" id="cb8-8" title="8"><span class="co">arr [1] means the maximum amount of money you get if you rob root */</span></a>
<a class="sourceLine" id="cb8-9" title="9"><span class="dt">int</span>[] <span class="fu">dp</span>(<span class="bu">TreeNode</span> root) {</a>
<a class="sourceLine" id="cb8-10" title="10">    <span class="kw">if</span> (root == <span class="kw">null</span>)</a>
<a class="sourceLine" id="cb8-11" title="11">        <span class="kw">return</span> <span class="kw">new</span> <span class="dt">int</span>[]{<span class="dv">0</span>, <span class="dv">0</span>};</a>
<a class="sourceLine" id="cb8-12" title="12">    <span class="dt">int</span>[] left = <span class="fu">dp</span>(root.<span class="fu">left</span>);</a>
<a class="sourceLine" id="cb8-13" title="13">    <span class="dt">int</span>[] right = <span class="fu">dp</span>(root.<span class="fu">right</span>);</a>
<a class="sourceLine" id="cb8-14" title="14">    <span class="co">// rob, walk to the house after next</span></a>
<a class="sourceLine" id="cb8-15" title="15">    <span class="dt">int</span> rob = root.<span class="fu">val</span> + left[<span class="dv">0</span>] + right[<span class="dv">0</span>];</a>
<a class="sourceLine" id="cb8-16" title="16">    <span class="co">// not rob, The next home can be robbed or not, depending on the size of the income</span></a>
<a class="sourceLine" id="cb8-17" title="17">    <span class="dt">int</span> not_rob = <span class="bu">Math</span>.<span class="fu">max</span>(left[<span class="dv">0</span>], left[<span class="dv">1</span>])</a>
<a class="sourceLine" id="cb8-18" title="18"></a>
<a class="sourceLine" id="cb8-19" title="19">                + <span class="bu">Math</span>.<span class="fu">max</span>(right[<span class="dv">0</span>], right[<span class="dv">1</span>]);</a>
<a class="sourceLine" id="cb8-20" title="20"></a>
<a class="sourceLine" id="cb8-21" title="21">    </a>
<a class="sourceLine" id="cb8-22" title="22">    <span class="kw">return</span> <span class="kw">new</span> <span class="dt">int</span>[]{not_rob, rob};</a>
<a class="sourceLine" id="cb8-23" title="23">}</a></code></pre></div>
<p>The time complexity is O (N). The space complexity is only the space required by the recursive function stack, and no extra space is needed for the memo.</p>
<p>His thinking is different from ours. He has modified the definition of recursive functions and slightly modified his thinking so that the logic is self-consistent, he still gets the correct answer, and the code is more beautiful. This is a characteristic of the dynamic programming problem that we mentioned earlier in [Different Definitions Generate Different Solutions].</p>
<p>In fact, this solution runs much faster than our solution, although the time complexity of the algorithm analysis level is the same. The reason is that this solution does not use additional memos, which reduces the complexity of data operations, so the actual operation efficiency will be faster.</p>
</body>
</html>
