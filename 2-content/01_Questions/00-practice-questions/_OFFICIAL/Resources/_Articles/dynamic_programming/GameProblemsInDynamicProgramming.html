<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>GameProblemsInDynamicProgramming</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="game-problems-in-dynamic-programming">Game Problems In Dynamic Programming</h1>
<p><strong>Translator: <a href="https://github.com/wadegrc">wadegrc</a></strong></p>
<p><strong>Author: <a href="https://github.com/labuladong">labuladong</a></strong></p>
<p>In the last article, we discussed a fun「stone game 」in <a href="../高频面试系列/一行代码解决的智力题.md">several puzzles</a>, By the constraints of the problem, the game is first to win. But intelligence questions are always intelligence questions, Real algorithmic problems are not solved by cutting corners. So this paper is going to talk about the stone game and assuming that both of these guys are smart enough, who’s going to win in the end how do you solve this problem with dynamic programming.</p>
<p>Game problems follow a similar pattern, The core idea is to use tuples to store the game results of two people on the basis of two-dimensional dp array. Once you’re mastered this technique, if someone asks you a similar question again, you can take it in stride.</p>
<p>We changed the stone game to be more general:</p>
<p>There is a pile of stones in front of you and your friends, it’s represented by an array of piles, and piles[i] is how many stones are there in the ith heap. You take turns with the stones, one pile at a time, but you can only take the left or the right piles. After all the stones have been taken away, the last one who has more stones wins.</p>
<p>The heap number of stones can be any positive integer, and the total number of stones can be any positive integer, That would break the situation in which one must win first. Let’s say I have three piles of rocks: <code>piles = [1, 100, 3]</code> , Whether it’s a 1or a 3, the 100 that’s going to make the difference is going to be taken away by the back hand, and the back hand is going to win.</p>
<p><strong>Assuming they are both smart</strong>, design an algorithm that returns the difference between the final score of the first hand and the last hand, As in the example above, the first hand gets 4 points, the second hand gets 100 points, and you should return -96.</p>
<p>With this design, this problem is a Hard dynamic programming problem.<strong>The difficuty with gaming is that two people have to take turns choosing, and they’re both smart. How do we program?</strong></p>
<p>It’s the approach that’s been emphasized many times, The first step is to define the array, and then, like the stock buying and selling series, once you find the「status」and the「selection」, and then it’s easy.</p>
<h3 id="define-the-meaning-of-the-dp-array">1. Define the meaning of the dp array:</h3>
<p>Defining what a dp array means is very tachnical, The dp array of the same problem can be defined in several ways. Different definitions lead to different state transition equations, But as long as there’s no logic problem, you end up with the same answer. I recommend that you don’t get caught up in what looks like a great short technique, and that you end up with something that’s a little bit more stable, something that’s the most interpretable, and something that’s the easiest to generalize, This paper gives a general design framework of game problem.</p>
<p>Before we introduce what a dp array means, let’s take a look at what it ultimately looks like:</p>
<figure>
<img src="../pictures/GameProblems/1.png" alt="1" /><figcaption>1</figcaption>
</figure>
<p>As explained below, tupels are considered to be a calss containing first and second atrributes, And to save space, these two atrributes are abbreviated to fir and sec. As shown in the figure above, we think <code>dp[1][3].fir = 10</code> ， <code>dp[0][1].sec = 3</code> .</p>
<p>Start by answering a few questions that readers might ask:</p>
<p>This is a two-dimensional dp table that stores tuples. How do you represent that? Half of this array is useless, How do you optimize it? Very simple, do not care, first to think out the way to solve the problem again.</p>
<p><strong>Here’s an explanation of what a dp array means:</strong></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" title="1">dp[i][j].fir represents the highest score the first hand can get <span class="cf">for</span> this section of the pile piles[i...j]</a>
<a class="sourceLine" id="cb1-2" title="2">dp[i][j].sec represents the highest score the back hand can get <span class="cf">for</span> this section of the pile piles[i...j]</a>
<a class="sourceLine" id="cb1-3" title="3"></a>
<a class="sourceLine" id="cb1-4" title="4">Just to give you an example,Assuming piles <span class="op">=</span> [<span class="dv">3</span>, <span class="dv">9</span>, <span class="dv">1</span>, <span class="dv">2</span>],The inedx starts at <span class="dv">0</span></a>
<a class="sourceLine" id="cb1-5" title="5">dp[<span class="dv">0</span>][<span class="dv">1</span>].fir <span class="op">=</span> <span class="dv">9</span> means:Facing the pile of stones [<span class="dv">3</span>, <span class="dv">9</span>],The first player eventually gets <span class="dv">9</span> points.</a>
<a class="sourceLine" id="cb1-6" title="6">dp[<span class="dv">1</span>][<span class="dv">3</span>].sec <span class="op">=</span> <span class="dv">2</span> means:Facing the pile of stones [<span class="dv">9</span>, <span class="dv">1</span>, <span class="dv">2</span>],The second player eventually gets <span class="dv">2</span> points.</a></code></pre></div>
<p>The answer we want is the difference between the final score of the first hand and the final score of the second hand, By thisdefinition, that is <span class="math inline"><em>d</em><em>p</em>[0][<em>n</em> − 1].<em>f</em><em>i</em><em>r</em> − <em>d</em><em>p</em>[0][<em>n</em> − 1].<em>s</em><em>e</em><em>c</em></span> That is, facing the whole piles, the difference between the best score of the first hand and the best score of the second hand.</p>
<h3 id="state-transition-equation">2.state transition equation:</h3>
<p>It’s easy to write the transition equation, The first step is to find all the states and the choices you can make for each state, and then pick the best.</p>
<p>From the previous definition of the dp array, <strong>there are obviously three states:the starting index i, the ending index j, and the person whose turn it is.</strong></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" title="1">dp[i][j][fir <span class="kw">or</span> sec]</a>
<a class="sourceLine" id="cb2-2" title="2">range：</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="dv">0</span> <span class="op">&lt;=</span> i <span class="op">&lt;</span> piles.length</a>
<a class="sourceLine" id="cb2-4" title="4">i <span class="op">&lt;=</span> j <span class="op">&lt;</span> piles.length</a></code></pre></div>
<p>For each state of the problem, <strong>there are two choices you can make : Choose the pile to the left, or the pile to the right</strong>. We can do all the states like this :</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" title="1">n <span class="op">=</span> piles.length</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="cf">for</span> <span class="dv">0</span> <span class="op">&lt;=</span> i <span class="op">&lt;</span> n:</a>
<a class="sourceLine" id="cb3-3" title="3">    <span class="cf">for</span> j <span class="op">&lt;=</span> i <span class="op">&lt;</span> n:</a>
<a class="sourceLine" id="cb3-4" title="4">        <span class="cf">for</span> who <span class="kw">in</span> {fir, sec}:</a>
<a class="sourceLine" id="cb3-5" title="5">            dp[i][j][who] <span class="op">=</span> <span class="bu">max</span>(left, right)</a></code></pre></div>
<p>The pseudocode above is a rough framework for dynamic programming, and there is a similar pseudocode in the stock series problem. The difficulty of this problem is that two people choose alternately, that is to say, the choice of the first hand has effect on the second hand, how can we express this?</p>
<p>According to our definition of dp array, it is easy to solve this difficulty and <strong>write down the state transition equation</strong>:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" title="1">dp[i][j].fir <span class="op">=</span> <span class="bu">max</span>(piles[i] <span class="op">+</span> dp[i<span class="op">+</span><span class="dv">1</span>][j].sec, piles[j] <span class="op">+</span> dp[i][j<span class="dv">-1</span>].sec)</a>
<a class="sourceLine" id="cb4-2" title="2">dp[i][j].fir <span class="op">=</span> <span class="bu">max</span>(    Select the rock pile on the far left     ,     Select the rock pile on the far right     )</a>
<a class="sourceLine" id="cb4-3" title="3"><span class="co"># explanation：I,as a first hand,faced piles[i...j],I had two choices：</span></a>
<a class="sourceLine" id="cb4-4" title="4"><span class="co"># If I choose the pile of rocks on the far left,and  I will face piles[i+1...j]</span></a>
<a class="sourceLine" id="cb4-5" title="5"><span class="co"># But when it came to the other side,I became the back hand.</span></a>
<a class="sourceLine" id="cb4-6" title="6"><span class="co"># If I choose the pile of rocks on the far right,and  I will face piles[i...j-1]</span></a>
<a class="sourceLine" id="cb4-7" title="7"><span class="co"># But when it came to the other side,I became the back hand.</span></a>
<a class="sourceLine" id="cb4-8" title="8"></a>
<a class="sourceLine" id="cb4-9" title="9"><span class="cf">if</span> the first hand select the left:</a>
<a class="sourceLine" id="cb4-10" title="10">    dp[i][j].sec <span class="op">=</span> dp[i<span class="op">+</span><span class="dv">1</span>][j].fir</a>
<a class="sourceLine" id="cb4-11" title="11"><span class="cf">if</span> the first hand select the right:</a>
<a class="sourceLine" id="cb4-12" title="12">    dp[i][j].sec <span class="op">=</span> dp[i][j<span class="dv">-1</span>].fir</a>
<a class="sourceLine" id="cb4-13" title="13"><span class="co"># explanation：I,as a back hand ,have to wait for the first hand to choose,There are two condition:</span></a>
<a class="sourceLine" id="cb4-14" title="14"><span class="co">#  If the first hand choose the pile of rocks on the far left,I will face piles[i+1...j]</span></a>
<a class="sourceLine" id="cb4-15" title="15"><span class="co"># then it&#39;s my turn, and i become the first hand.</span></a>
<a class="sourceLine" id="cb4-16" title="16"><span class="co"># If the first hand choose the pile of rocks on the far right,I will face piles[i...j-1]</span></a>
<a class="sourceLine" id="cb4-17" title="17"><span class="co"># then it&#39;s my turn, and i become the first hand.</span></a></code></pre></div>
<p>According to the definition of the dp array, we can also find the <strong>base case</strong>, which is the simplest case:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" title="1">dp[i][j].fir <span class="op">=</span> piles[i]</a>
<a class="sourceLine" id="cb5-2" title="2">dp[i][j].sec <span class="op">=</span> <span class="dv">0</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="bu">range</span>: <span class="dv">0</span> <span class="op">&lt;=</span> i <span class="op">==</span> j <span class="op">&lt;</span> n</a>
<a class="sourceLine" id="cb5-4" title="4"><span class="co"># explanation：i==j which means just a bunch of rocks piles[i] in the front of us</span></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="co"># So obviously the first hand can get piles[i],</span></a>
<a class="sourceLine" id="cb5-6" title="6"><span class="co"># there are no stones int the back,so his score is 0</span></a></code></pre></div>
<figure>
<img src="../pictures/GameProblems/2.png" alt="2" /><figcaption>2</figcaption>
</figure>
<p>One thing to note here is that we found that the base case is tilted in the table, and we need dp[i+1][j] and dp[i][j-1] to compute dp[i][j]:</p>
<figure>
<img src="../pictures/GameProblems/3.png" alt="3" /><figcaption>3</figcaption>
</figure>
<p>So the algorithm can not simply traverse the dp array row by row, but <strong>traverse the array diagonally</strong>.</p>
<figure>
<img src="../pictures/GameProblems/4.png" alt="4" /><figcaption>4</figcaption>
</figure>
<p>To be honest, traversing a two-dimensional array diagonally is easier said than done.</p>
<h3 id="code-implementation">3.code implementation</h3>
<p>How do you implement this fir and sec tuple? You can either use python, with its own tuple type, or use the c++pair container, or use a three-dimensional array, the last dimension being the tuple, or we can write a pair class ourselves.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">class</span> Pair {</a>
<a class="sourceLine" id="cb6-2" title="2">    <span class="dt">int</span> fir, sec;</a>
<a class="sourceLine" id="cb6-3" title="3">    <span class="fu">Pair</span>(<span class="dt">int</span> fir, <span class="dt">int</span> sec) {</a>
<a class="sourceLine" id="cb6-4" title="4">        <span class="kw">this</span>.<span class="fu">fir</span> = fir;</a>
<a class="sourceLine" id="cb6-5" title="5">        <span class="kw">this</span>.<span class="fu">sec</span> = sec;</a>
<a class="sourceLine" id="cb6-6" title="6">    }</a>
<a class="sourceLine" id="cb6-7" title="7">}</a></code></pre></div>
<p>Then we can directly translate our state transition equation into code, and we can pay attention to technique of traversing through array diagonally:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb7-1" title="1"><span class="co">/* Returns the difference between the last first hand and last hand */</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="dt">int</span> <span class="fu">stoneGame</span>(<span class="dt">int</span>[] piles) {</a>
<a class="sourceLine" id="cb7-3" title="3">    <span class="dt">int</span> n = piles.<span class="fu">length</span>;</a>
<a class="sourceLine" id="cb7-4" title="4">    <span class="co">//Initializes the dp array</span></a>
<a class="sourceLine" id="cb7-5" title="5">    Pair[][] dp = <span class="kw">new</span> Pair[n][n];</a>
<a class="sourceLine" id="cb7-6" title="6">    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) </a>
<a class="sourceLine" id="cb7-7" title="7">        <span class="kw">for</span> (<span class="dt">int</span> j = i; j &lt; n; j++)</a>
<a class="sourceLine" id="cb7-8" title="8">            dp[i][j] = <span class="kw">new</span> <span class="fu">Pair</span>(<span class="dv">0</span>, <span class="dv">0</span>);</a>
<a class="sourceLine" id="cb7-9" title="9">    <span class="co">// base case</span></a>
<a class="sourceLine" id="cb7-10" title="10">    <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt; n; i++) {</a>
<a class="sourceLine" id="cb7-11" title="11">        dp[i][i].<span class="fu">fir</span> = piles[i];</a>
<a class="sourceLine" id="cb7-12" title="12">        dp[i][i].<span class="fu">sec</span> = <span class="dv">0</span>;</a>
<a class="sourceLine" id="cb7-13" title="13">    }</a>
<a class="sourceLine" id="cb7-14" title="14">    <span class="co">// traverse the array diagonally</span></a>
<a class="sourceLine" id="cb7-15" title="15">    <span class="kw">for</span> (<span class="dt">int</span> l = <span class="dv">2</span>; l &lt;= n; l++) {</a>
<a class="sourceLine" id="cb7-16" title="16">        <span class="kw">for</span> (<span class="dt">int</span> i = <span class="dv">0</span>; i &lt;= n - l; i++) {</a>
<a class="sourceLine" id="cb7-17" title="17">            <span class="dt">int</span> j = l + i - <span class="dv">1</span>;</a>
<a class="sourceLine" id="cb7-18" title="18">            <span class="co">// The first hand select the left- or right-most pile.</span></a>
<a class="sourceLine" id="cb7-19" title="19">            <span class="dt">int</span> left = piles[i] + dp[i+<span class="dv">1</span>][j].<span class="fu">sec</span>;</a>
<a class="sourceLine" id="cb7-20" title="20">            <span class="dt">int</span> right = piles[j] + dp[i][j-<span class="dv">1</span>].<span class="fu">sec</span>;</a>
<a class="sourceLine" id="cb7-21" title="21">            <span class="co">// Refer to the state transition equation.</span></a>
<a class="sourceLine" id="cb7-22" title="22">            <span class="kw">if</span> (left &gt; right) {</a>
<a class="sourceLine" id="cb7-23" title="23">                dp[i][j].<span class="fu">fir</span> = left;</a>
<a class="sourceLine" id="cb7-24" title="24">                dp[i][j].<span class="fu">sec</span> = dp[i+<span class="dv">1</span>][j].<span class="fu">fir</span>;</a>
<a class="sourceLine" id="cb7-25" title="25">            } <span class="kw">else</span> {</a>
<a class="sourceLine" id="cb7-26" title="26">                dp[i][j].<span class="fu">fir</span> = right;</a>
<a class="sourceLine" id="cb7-27" title="27">                dp[i][j].<span class="fu">sec</span> = dp[i][j-<span class="dv">1</span>].<span class="fu">fir</span>;</a>
<a class="sourceLine" id="cb7-28" title="28">            }</a>
<a class="sourceLine" id="cb7-29" title="29">        }</a>
<a class="sourceLine" id="cb7-30" title="30">    }</a>
<a class="sourceLine" id="cb7-31" title="31">    Pair res = dp[<span class="dv">0</span>][n-<span class="dv">1</span>];</a>
<a class="sourceLine" id="cb7-32" title="32">    <span class="kw">return</span> res.<span class="fu">fir</span> - res.<span class="fu">sec</span>;</a>
<a class="sourceLine" id="cb7-33" title="33">}</a></code></pre></div>
<p>Dynamic programming , the most important is to understand the state transition equation, based on the previous detailed explanation, the reader should be able to clearly understand the meaning of this large piece of code.</p>
<p>And notice that the calculation of ‘dp[i][j]’ only depends on the left and the bottom elements, so there must be room for optimization, for one-dimensional dp, But one-dimensional dp is a little bit more complicated, it’s less interpretable, so you don’t have to waste time trying to understand it.</p>
<h3 id="summary">4.summary:</h3>
<p>This paper presents a dynamic programming method to solve the game problem. The premise of game problems is usually between two smart people. The common way to describe such games is a one-dimensional array of dp, in which tuples represent the optimal decision of two people.</p>
<p>The reason for this design is that when the first hand makes a choice, it becomes the second hand, and when the second hand makes a choice, it becomes the first hand. This role reversal allows us to reuse the previous results, typical dynamic programming flags.</p>
<p>Those of you who have read this should understand how algorithms solve game problems. Learning algorithms, must pay attention to the template framework of the algorithm, rather than some seemingly awesome ideas, do not bend to write an optimal solution. Don’t be afraid to use more space, don’t try optimization too early, and don’t be afraid of multidimensional arrays. A dp array is a way to store information and avoid double counting.</p>
<p>I hope this article has been helpful.</p>
</body>
</html>
