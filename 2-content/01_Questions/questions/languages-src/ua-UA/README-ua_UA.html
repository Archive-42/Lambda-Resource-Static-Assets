<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README-ua_UA</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="список-просунутих-питань-з-javascript">Список (просунутих) питань з JavaScript</h1>
<p>Я публікую щодня завдання з JavaScript в моєму <a href="https://www.instagram.com/theavocoder">Instagram</a>, які також додаю тут!</p>
<p>Від базового до просунутого: перевірте, наскільки добре ви знаєте JavaScript, трохи оновлюйте свої знання або підготуйтеся до інтерв’ю! :muscle: :rocket: Щотижня я доповнюю цей репозиторій новими питаннями.</p>
<p>Відповіді знаходяться в згорнутої секції нижче питань. Просто натисни на відповідь, щоб розгорнути. Успіхів! :heart:</p>
<ul>
<li><a href="../en-EN/README.md">English</a></li>
<li><a href="../ar-AR/README_AR.md">العربية</a></li>
<li><a href="../ar-EG/README_ar-EG.md">اللغة العامية - Egyptian Arabic</a></li>
<li><a href="../bs-BS/README-bs_BS.md">Bosanski</a><br />
</li>
<li><a href="../de-DE/README.md">Deutsch</a><br />
</li>
<li><a href="../es-ES/README-ES.md">Español</a></li>
<li><a href="../fr-FR/README_fr-FR.md">Français</a></li>
<li><a href="../ja-JA/README-ja_JA.md">日本語</a><br />
</li>
<li><a href="../ko-KR/README-ko_KR.md">한국어</a></li>
<li><a href="./nl-NL/README.md">Nederlands</a></li>
<li><a href="../pt-BR/README_pt_BR.md">Português Brasil</a><br />
</li>
<li><a href="../ru-RU/README.md">Русский</a></li>
<li><a href="../ua-UA/README-ua_UA.md">Українська мова</a><br />
</li>
<li><a href="../vi-VI/README-vi.md">Tiếng Việt</a></li>
<li><a href="../zh-CN/README-zh_CN.md">中文版本</a></li>
<li><a href="../tr-TR/README-tr_TR.md">Türkçe</a></li>
<li><a href="../th-TH/README-th_TH.md">ไทย</a></li>
</ul>
<hr />
<h6 id="що-буде-в-консолі">1. Що буде в консолі?</h6>
<div class="sourceCode" id="cb1"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">function</span> <span class="at">sayHi</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb1-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(name)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(age)<span class="op">;</span></a>
<a class="sourceLine" id="cb1-4" title="4">  <span class="kw">var</span> name <span class="op">=</span> <span class="st">&quot;Lydia&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-5" title="5">  <span class="kw">let</span> age <span class="op">=</span> <span class="dv">21</span><span class="op">;</span></a>
<a class="sourceLine" id="cb1-6" title="6"><span class="op">}</span></a>
<a class="sourceLine" id="cb1-7" title="7"></a>
<a class="sourceLine" id="cb1-8" title="8"><span class="at">sayHi</span>()<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>Lydia</code> та <code>undefined</code></li>
<li>B: <code>Lydia</code> та <code>ReferenceError</code></li>
<li>C: <code>ReferenceError</code> та <code>21</code></li>
<li>D: <code>undefined</code> та <code>ReferenceError</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-d">Відповідь: D</h4>
<p>Усередині функції ми спершу визначаємо змінну <code>name</code> за допомогою ключового слова <code>var</code>. Це означає, що змінна буде знайдена (область пам’яті під змінну буде виділена під час створення) зі значенням <code>undefined</code> за замовчуванням, до тих пір поки виконання коду не дійде до рядка, де визначається змінна. Ми ще не визначили значення <code>name</code>, коли намагаємося вивести її в консоль, тому в консолі буде <code>undefined</code>.</p>
<p>Змінні, визначені за допомогою <code>let</code> (і <code>const</code>), також знаходяться, але на відміну від <code>var</code>, не <i>створюються</i>. Доступ до них неможливий до тих пір, поки не виконається рядок їх визначення (ініціалізації). Це називається “тимчасова мертва зона”. Коли ми намагаємося звернутися до змінних до того моменту як вони визначені, JavaScript видає <code>ReferenceError</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-1">2. Що буде в консолі?</h6>
<div class="sourceCode" id="cb2"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb2-1" title="1"><span class="cf">for</span> (<span class="kw">var</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-2" title="2">  <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(i)<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb2-4" title="4"></a>
<a class="sourceLine" id="cb2-5" title="5"><span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">0</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">3</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb2-6" title="6">  <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(i)<span class="op">,</span> <span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb2-7" title="7"><span class="op">}</span></a></code></pre></div>
<ul>
<li>A: <code>0 1 2</code> та <code>0 1 2</code></li>
<li>B: <code>0 1 2</code> та <code>3 3 3</code></li>
<li>C: <code>3 3 3</code> та <code>0 1 2</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c">Відповідь: C</h4>
<p>Через черги подій в JavaScript, функція <code>setTimeout</code> викликається <em>після того</em> як цикл буде завершено. Так як змінна <code>i</code> в першому циклі була визначена за допомогою <code>var</code>, вона буде глобальною. У циклі ми кожен раз збільшуємо значення <code>i</code> на <code>1</code>, використовуючи унарний оператор <code>++.</code> До моменту виконання функції <code>setTimeout</code> значення <code>i</code> дорівнюватиме <code>3</code>, як показано в першому прикладі.</p>
<p>У другому циклі змінна <code>i</code> визначена за допомогою <code>let</code>. Такі змінні (а також <code>const</code>) мають блочну область видимості (блок це що завгодно між <code>{}</code>). З кожної итерацией <code>i</code> матиме нове значення, і кожне значення буде замкнуто в своїй області видимості всередині циклу.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-2">3. Що буде в консолі?</h6>
<div class="sourceCode" id="cb3"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">const</span> shape <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb3-2" title="2">  <span class="dt">radius</span><span class="op">:</span> <span class="dv">10</span><span class="op">,</span></a>
<a class="sourceLine" id="cb3-3" title="3">  <span class="at">diameter</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb3-4" title="4">    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">radius</span> <span class="op">*</span> <span class="dv">2</span><span class="op">;</span></a>
<a class="sourceLine" id="cb3-5" title="5">  <span class="op">},</span></a>
<a class="sourceLine" id="cb3-6" title="6">  <span class="dt">perimeter</span><span class="op">:</span> () <span class="kw">=&gt;</span> <span class="dv">2</span> <span class="op">*</span> <span class="va">Math</span>.<span class="at">PI</span> <span class="op">*</span> <span class="kw">this</span>.<span class="at">radius</span></a>
<a class="sourceLine" id="cb3-7" title="7"><span class="op">};</span></a>
<a class="sourceLine" id="cb3-8" title="8"></a>
<a class="sourceLine" id="cb3-9" title="9"><span class="va">shape</span>.<span class="at">diameter</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb3-10" title="10"><span class="va">shape</span>.<span class="at">perimeter</span>()<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>20</code> та <code>62.83185307179586</code></li>
<li>B: <code>20</code> та <code>NaN</code></li>
<li>C: <code>20</code> та <code>63</code></li>
<li>D: <code>NaN</code> та <code>63</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-b">Відповідь: B</h4>
<p>Зауваж, що <code>diameter</code> це звичайна функція, в той час як <code>perimeter</code> це функція стрілки.</p>
<p>У стрілочних функцій значення <code>this</code> вказує на навколишню область видимості, на відміну від звичайних функцій! Це означає, що при виклику <code>perimeter</code> значення <code>this</code> у цій функції вказує не на об’єкт <code>shape</code>, а на зовнішню область видимості (наприклад, window).</p>
<p>У цього об’єкта немає ключа <code>radius</code>, тому повертається <code>undefined</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-3">4. Що буде в консолі?</h6>
<div class="sourceCode" id="cb4"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb4-1" title="1"><span class="op">+</span><span class="kw">true</span><span class="op">;</span></a>
<a class="sourceLine" id="cb4-2" title="2"><span class="op">!</span><span class="st">&quot;Lydia&quot;</span><span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>1</code> та <code>false</code></li>
<li>B: <code>false</code> та <code>NaN</code></li>
<li>C: <code>false</code> та <code>false</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a">Відповідь: A</h4>
<p>Унарний плюс призводить операнд до числа. <code>true</code> це <code>1</code>, а <code>false</code> це <code>0</code>.</p>
<p>Строка <code>'Lydia'</code> це “справжнє” значення. Ми запитуємо “справжнє значення є помилковим”? Відповідь: <code>false</code>.</p>
</p>
</details>
<hr />
<h6 id="що-з-цього-не-є-коректним">5. Що з цього не є коректним?</h6>
<div class="sourceCode" id="cb5"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">const</span> bird <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-2" title="2">  <span class="dt">size</span><span class="op">:</span> <span class="st">&quot;small&quot;</span></a>
<a class="sourceLine" id="cb5-3" title="3"><span class="op">};</span></a>
<a class="sourceLine" id="cb5-4" title="4"></a>
<a class="sourceLine" id="cb5-5" title="5"><span class="kw">const</span> mouse <span class="op">=</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb5-6" title="6">  <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Mickey&quot;</span><span class="op">,</span></a>
<a class="sourceLine" id="cb5-7" title="7">  <span class="dt">small</span><span class="op">:</span> <span class="kw">true</span></a>
<a class="sourceLine" id="cb5-8" title="8"><span class="op">};</span></a></code></pre></div>
<ul>
<li>A: <code>mouse.bird.size</code> не є коректно</li>
<li>B: <code>mouse[bird.size]</code> не є коректно</li>
<li>C: <code>mouse[bird["size"]]</code> не є коректно</li>
<li>D: Все варіант коректні</li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-1">Відповідь: A</h4>
<p>В JavaScript все ключі об’єкта є рядками (крім <code>Symbol</code>). І хоча ми не <em>набираємо</em> їх як рядки, вони завжди перетворюються до рядків під капотом.</p>
<p>JavaScript інтерпретує (або розпаковує) оператори. При використанні квадратних дужок JS зауважує <code>[</code> і продовжує поки не зустріне <code>]</code>. Тільки після цього він вирахує то, що знаходиться всередині дужок.</p>
<p><code>mouse[bird.size]</code>: Спершу визначається <code>bird.size</code>, що дорівнює <code>"small"</code>. <code>mouse["small"]</code> повертає <code>true</code>.</p>
<p>Але із записом через точку так не відбувається. У <code>mouse</code> немає ключа <code>bird</code>. Таким чином, <code>mouse.bird</code> дорівнює <code>undefined</code>. Потім ми запитуємо ключ <code>size</code>, використовуючи точкову нотацію: <code>mouse.bird.size</code>. Так як <code>mouse.bird</code> це <code>undefined</code>, ми запитуємо <code>undefined.size</code>. Це не є дійсним, і ми отримуємо помилку типу: <code>Can not read property "size" of undefined</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-4">6. Що буде в консолі?</h6>
<div class="sourceCode" id="cb6"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb6-1" title="1"><span class="kw">let</span> c <span class="op">=</span> <span class="op">{</span> <span class="dt">greeting</span><span class="op">:</span> <span class="st">&quot;Hey!&quot;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb6-2" title="2"><span class="kw">let</span> d<span class="op">;</span></a>
<a class="sourceLine" id="cb6-3" title="3"></a>
<a class="sourceLine" id="cb6-4" title="4">d <span class="op">=</span> c<span class="op">;</span></a>
<a class="sourceLine" id="cb6-5" title="5"><span class="va">c</span>.<span class="at">greeting</span> <span class="op">=</span> <span class="st">&quot;Hello&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb6-6" title="6"><span class="va">console</span>.<span class="at">log</span>(<span class="va">d</span>.<span class="at">greeting</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>Hello</code></li>
<li>B: <code>Hey</code></li>
<li>C: <code>undefined</code></li>
<li>D: <code>ReferenceError</code></li>
<li>E: <code>TypeError</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-2">Відповідь: A</h4>
<p>В JavaScript всі об’єкти є <em>посилальними</em> типами даних.</p>
<p>Спершу змінна <code>c</code> вказує на об’єкт. Потім ми вказуємо змінної <code>d</code> посилатися на той самий об’єкт, що і <code>c</code>.</p>
<p><img src="https://i.imgur.com/ko5k0fs.png" width="200"></p>
<p>Коли ти змінюєш один об’єкт, то змінюються значення всіх посилань, що вказують на цей об’єкт.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-5">7. Що буде в консолі?</h6>
<div class="sourceCode" id="cb7"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">let</span> a <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-2" title="2"><span class="kw">let</span> b <span class="op">=</span> <span class="kw">new</span> <span class="at">Number</span>(<span class="dv">3</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-3" title="3"><span class="kw">let</span> c <span class="op">=</span> <span class="dv">3</span><span class="op">;</span></a>
<a class="sourceLine" id="cb7-4" title="4"></a>
<a class="sourceLine" id="cb7-5" title="5"><span class="va">console</span>.<span class="at">log</span>(a <span class="op">==</span> b)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-6" title="6"><span class="va">console</span>.<span class="at">log</span>(a <span class="op">===</span> b)<span class="op">;</span></a>
<a class="sourceLine" id="cb7-7" title="7"><span class="va">console</span>.<span class="at">log</span>(b <span class="op">===</span> c)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>true</code> <code>false</code> <code>true</code></li>
<li>B: <code>false</code> <code>false</code> <code>true</code></li>
<li>C: <code>true</code> <code>false</code> <code>false</code></li>
<li>D: <code>false</code> <code>true</code> <code>true</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-1">Відповідь: C</h4>
<p><code>new Number()</code> це вбудований конструктор функції. І хоча він виглядає як число, це не справжнє число: у нього є ряд додаткових фіч і це об’єкт.</p>
<p>Оператор <code>==</code> призводить типи даних до якогось одного і перевіряє рівність <em>значень</em>. Обидва значення рівні <code>3</code>, тому повертається <code>true</code>.</p>
<p>При використанні оператора <code>===</code> значення і тип повинні бути однаковими. Але в нашому випадку це не так: <code>new Number()</code> це не число, це <strong>об’єкт</strong>. Тому обидва повертають <code>false</code>.</p>
</p>
</details>
<hr />
<h6 id="яким-буде-результат">8. Яким буде результат?</h6>
<div class="sourceCode" id="cb8"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb8-1" title="1"><span class="kw">class</span> Chameleon <span class="op">{</span></a>
<a class="sourceLine" id="cb8-2" title="2">  <span class="kw">static</span> <span class="at">colorChange</span>(newColor) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-3" title="3">    <span class="kw">this</span>.<span class="at">newColor</span> <span class="op">=</span> newColor<span class="op">;</span></a>
<a class="sourceLine" id="cb8-4" title="4">    <span class="cf">return</span> <span class="kw">this</span>.<span class="at">newColor</span><span class="op">;</span></a>
<a class="sourceLine" id="cb8-5" title="5">  <span class="op">}</span></a>
<a class="sourceLine" id="cb8-6" title="6"></a>
<a class="sourceLine" id="cb8-7" title="7">  <span class="at">constructor</span>(<span class="op">{</span> newColor <span class="op">=</span> <span class="st">&quot;green&quot;</span> <span class="op">}</span> <span class="op">=</span> <span class="op">{}</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb8-8" title="8">    <span class="kw">this</span>.<span class="at">newColor</span> <span class="op">=</span> newColor<span class="op">;</span></a>
<a class="sourceLine" id="cb8-9" title="9">  <span class="op">}</span></a>
<a class="sourceLine" id="cb8-10" title="10"><span class="op">}</span></a>
<a class="sourceLine" id="cb8-11" title="11"></a>
<a class="sourceLine" id="cb8-12" title="12"><span class="kw">const</span> freddie <span class="op">=</span> <span class="kw">new</span> <span class="at">Chameleon</span>(<span class="op">{</span> <span class="dt">newColor</span><span class="op">:</span> <span class="st">&quot;purple&quot;</span> <span class="op">}</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb8-13" title="13"><span class="va">freddie</span>.<span class="at">colorChange</span>(<span class="st">&quot;orange&quot;</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>orange</code></li>
<li>B: <code>purple</code></li>
<li>C: <code>green</code></li>
<li>D: <code>TypeError</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-d-1">Відповідь: D</h4>
<p>Функція <code>colorChange</code> є статичною. Статичні методи не мають доступу до екземплярів класу. Так як <code>freddie</code> це екземпляр, то статичний метод там не доступний. Тому результатом є помилка <code>TypeError</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-6">9. Що буде в консолі?</h6>
<div class="sourceCode" id="cb9"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">let</span> greeting<span class="op">;</span></a>
<a class="sourceLine" id="cb9-2" title="2">greetign <span class="op">=</span> <span class="op">{};</span> <span class="co">// Typo!</span></a>
<a class="sourceLine" id="cb9-3" title="3"><span class="va">console</span>.<span class="at">log</span>(greetign)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>{}</code></li>
<li>B: <code>ReferenceError: greetign is not defined</code></li>
<li>C: <code>undefined</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-3">Відповідь: A</h4>
<p>В консолі виведеться об’єкт, тому що ми тільки що створили порожній об’єкт в глобальному об’єкті! Коли ми замість <code>greeting</code> написали <code>greetign</code>, інтерпретатор JS насправді виконав <code>global.greetign = {}</code> (або <code>window.greetign = {}</code> в браузері).</p>
<p>Потрібно використовувати <code>"use strict"</code>, щоб уникнути такої поведінки. Ця запис допоможе бути впевненим в тому, що змінна була визначена перед тим як їй присвоїли значення.</p>
</p>
</details>
<hr />
<h6 id="що-станеться">10. Що станеться?</h6>
<div class="sourceCode" id="cb10"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb10-1" title="1"><span class="kw">function</span> <span class="at">bark</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb10-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Woof!&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb10-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb10-4" title="4"></a>
<a class="sourceLine" id="cb10-5" title="5"><span class="va">bark</span>.<span class="at">animal</span> <span class="op">=</span> <span class="st">&quot;dog&quot;</span><span class="op">;</span></a></code></pre></div>
<ul>
<li>A: Нічого, все ок.</li>
<li>B: <code>SyntaxError</code>. Не можна додавати властивості функцій таким способом.</li>
<li>C: <code>undefined</code></li>
<li>D: <code>ReferenceError</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-4">Відповідь: A</h4>
<p>В JavaScript це можливо, тому що функції це об’єкти! (Все є об’єктами крім примітивів).</p>
<p>Функція - це спеціальний тип об’єкта, який можна викликати. Крім того, функція - це об’єкт з властивостями. Властивість такого об’єкта не можна викликати, так як воно не є функцією.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-7">11. Що буде в консолі?</h6>
<div class="sourceCode" id="cb11"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">function</span> <span class="at">Person</span>(firstName<span class="op">,</span> lastName) <span class="op">{</span></a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="kw">this</span>.<span class="at">firstName</span> <span class="op">=</span> firstName<span class="op">;</span></a>
<a class="sourceLine" id="cb11-3" title="3">  <span class="kw">this</span>.<span class="at">lastName</span> <span class="op">=</span> lastName<span class="op">;</span></a>
<a class="sourceLine" id="cb11-4" title="4"><span class="op">}</span></a>
<a class="sourceLine" id="cb11-5" title="5"></a>
<a class="sourceLine" id="cb11-6" title="6"><span class="kw">const</span> member <span class="op">=</span> <span class="kw">new</span> <span class="at">Person</span>(<span class="st">&quot;Lydia&quot;</span><span class="op">,</span> <span class="st">&quot;Hallie&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb11-7" title="7"><span class="va">Person</span>.<span class="at">getFullName</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb11-8" title="8">  <span class="cf">return</span> <span class="vs">`</span><span class="sc">${</span><span class="kw">this</span>.<span class="at">firstName</span><span class="sc">}</span><span class="vs"> </span><span class="sc">${</span><span class="kw">this</span>.<span class="at">lastName</span><span class="sc">}</span><span class="vs">`</span><span class="op">;</span></a>
<a class="sourceLine" id="cb11-9" title="9"><span class="op">};</span></a>
<a class="sourceLine" id="cb11-10" title="10"></a>
<a class="sourceLine" id="cb11-11" title="11"><span class="va">console</span>.<span class="at">log</span>(<span class="va">member</span>.<span class="at">getFullName</span>())<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>TypeError</code></li>
<li>B: <code>SyntaxError</code></li>
<li>C: <code>Lydia Hallie</code></li>
<li>D: <code>undefined</code> <code>undefined</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-5">Відповідь: A</h4>
<p>Не можна додавати властивості конструктору, як звичайному об’єкту. Якщо потрібно додати фичу всіх об’єктах, то необхідно використовувати прототипи. В даному випадку,</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode js"><code class="sourceCode javascript"><a class="sourceLine" id="cb12-1" title="1"><span class="va">Person</span>.<span class="va">prototype</span>.<span class="at">getFullName</span> <span class="op">=</span> <span class="kw">function</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb12-2" title="2">  <span class="cf">return</span> <span class="vs">`</span><span class="sc">${</span><span class="kw">this</span>.<span class="at">firstName</span><span class="sc">}</span><span class="vs"> </span><span class="sc">${</span><span class="kw">this</span>.<span class="at">lastName</span><span class="sc">}</span><span class="vs">`</span><span class="op">;</span></a>
<a class="sourceLine" id="cb12-3" title="3"><span class="op">};</span></a></code></pre></div>
<p>зробить метод <code>member.getFullName()</code> чинним. У чому тут перевага? Припустимо, що ми додали цей метод до конструктора. Можливо, не кожному екземпляру <code>Person</code> потрібен цей метод. Це призведе до великих втрат пам’яті, тому що всі екземпляри будуть мати цю властивість. Навпаки, якщо ми додамо цей метод тільки до прототипу, у нас буде тільки одне місце в пам’яті, до якого зможуть звертатися всі екземпляри!</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-8">12. Що буде в консолі?</h6>
<div class="sourceCode" id="cb13"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">function</span> <span class="at">Person</span>(firstName<span class="op">,</span> lastName) <span class="op">{</span></a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="kw">this</span>.<span class="at">firstName</span> <span class="op">=</span> firstName<span class="op">;</span></a>
<a class="sourceLine" id="cb13-3" title="3">  <span class="kw">this</span>.<span class="at">lastName</span> <span class="op">=</span> lastName<span class="op">;</span></a>
<a class="sourceLine" id="cb13-4" title="4"><span class="op">}</span></a>
<a class="sourceLine" id="cb13-5" title="5"></a>
<a class="sourceLine" id="cb13-6" title="6"><span class="kw">const</span> lydia <span class="op">=</span> <span class="kw">new</span> <span class="at">Person</span>(<span class="st">&quot;Lydia&quot;</span><span class="op">,</span> <span class="st">&quot;Hallie&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-7" title="7"><span class="kw">const</span> sarah <span class="op">=</span> <span class="at">Person</span>(<span class="st">&quot;Sarah&quot;</span><span class="op">,</span> <span class="st">&quot;Smith&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-8" title="8"></a>
<a class="sourceLine" id="cb13-9" title="9"><span class="va">console</span>.<span class="at">log</span>(lydia)<span class="op">;</span></a>
<a class="sourceLine" id="cb13-10" title="10"><span class="va">console</span>.<span class="at">log</span>(sarah)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>Person {firstName: "Lydia", lastName: "Hallie"}</code> та <code>undefined</code></li>
<li>B: <code>Person {firstName: "Lydia", lastName: "Hallie"}</code> та <code>Person {firstName: "Sarah", lastName: "Smith"}</code></li>
<li>C: <code>Person {firstName: "Lydia", lastName: "Hallie"}</code> та <code>{}</code></li>
<li>D:<code>Person {firstName: "Lydia", lastName: "Hallie"}</code> та <code>ReferenceError</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-6">Відповідь: A</h4>
<p>Для <code>sarah</code> ми не використали ключове слово <code>new</code>. Використання <code>new</code> призводить до створення нового об’єкта. Але без <code>new</code> він вказує на <strong>глобальний об’єкт</strong>!</p>
<p>Ми вказали, що <code>this.firstName</code> дорівнює <code>"Sarah"</code> і <code>this.lastName</code> дорівнює <code>"Smith"</code>. Насправді ми визначили <code>global.firstName = 'Sarah'</code> і <code>global.lastName = 'Smith'</code>. <code>sarah</code> залишилася <code>undefined</code>.</p>
</p>
</details>
<hr />
<h6 id="назвіть-три-фази-поширення-подій">13. Назвіть три фази поширення подій</h6>
<ul>
<li>A: Мета (Target) &gt; Захоплення (Capturing) &gt; Всплиття (Bubbling)</li>
<li>B: Всплиття (Bubbling) &gt; Мета (Target) &gt; Захоплення (Capturing)</li>
<li>C: Мета (Target) &gt; Всплиття (Bubbling) &gt; Захоплення (Capturing)</li>
<li>D: Захоплення (Capturing) &gt; Мета (Target) &gt; Всплиття (Bubbling)</li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-d-2">Відповідь: D</h4>
<p>Під час фази <strong>захоплення</strong> подія поширюється з елементів батьків до елемента мети. Після досягнення <strong>мети</strong> починається фаза <strong>спливання</strong>.</p>
<p><img src="https://i.imgur.com/N18oRgd.png" width="200"></p>
</p>
</details>
<hr />
<h6 id="все-объекты-имеют-прототипы">14. Все объекты имеют прототипы?</h6>
<ul>
<li>A: Так</li>
<li>B: Ні</li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-b-1">Відповідь: B</h4>
<p>Всі об’єкти мають прототипи, крім <strong>базового об’єкта</strong>. Базовий об’єкт має доступ до деяких методів і властивостей, таких як <code>.toString</code>. Саме тому ми можемо використовувати вбудовані методи JavaScript! Всі ці методи доступні в прототипі. Якщо JavaScript не може знайти метод безпосередньо у об’єкту, він продовжує пошук по ланцюжку прототипів поки не знайде.</p>
</p>
</details>
<hr />
<h6 id="результат-коду">15. Результат коду?</h6>
<div class="sourceCode" id="cb14"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">function</span> <span class="at">sum</span>(a<span class="op">,</span> b) <span class="op">{</span></a>
<a class="sourceLine" id="cb14-2" title="2">  <span class="cf">return</span> a <span class="op">+</span> b<span class="op">;</span></a>
<a class="sourceLine" id="cb14-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb14-4" title="4"></a>
<a class="sourceLine" id="cb14-5" title="5"><span class="at">sum</span>(<span class="dv">1</span><span class="op">,</span> <span class="st">&quot;2&quot;</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>NaN</code></li>
<li>B: <code>TypeError</code></li>
<li>C: <code>"12"</code></li>
<li>D: <code>3</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-2">Відповідь: C</h4>
<p>JavaScript це <strong>динамічно тіпізірованна мова</strong>: ми не визначаємо тип змінних. Змінні можуть автоматично бути перетворені з одного типу в інший без нашої участі, що називається <em>неявним приведенням типів</em>. <strong>Приведення</strong> це перетворення з одного типу в інший.</p>
<p>У цьому прикладі, JavaScript конвертувати число <code>1</code> в рядок, щоб операція усередині функції мала сенс і повернула значення. Під час складання числа (<code>1</code>) і рядки (<code>'2'</code>) число перетворюється до рядка. Ми можемо конкатеніровать рядки ось так: <code>"Hello" + "World"</code>. Таким чином, “<code>1"</code> + <code>"2"</code> повертає”<code>12"</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-9">16. Що буде в консолі?</h6>
<div class="sourceCode" id="cb15"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">let</span> number <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb15-2" title="2"><span class="va">console</span>.<span class="at">log</span>(number<span class="op">++</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-3" title="3"><span class="va">console</span>.<span class="at">log</span>(<span class="op">++</span>number)<span class="op">;</span></a>
<a class="sourceLine" id="cb15-4" title="4"><span class="va">console</span>.<span class="at">log</span>(number)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>1</code> <code>1</code> <code>2</code></li>
<li>B: <code>1</code> <code>2</code> <code>2</code></li>
<li>C: <code>0</code> <code>2</code> <code>2</code></li>
<li>D: <code>0</code> <code>1</code> <code>2</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-3">Відповідь: C</h4>
<p><strong>Постфіксний</strong> унарний оператор <code>++</code>:</p>
<ol type="1">
<li>Повертає значення (<code>0</code>)</li>
<li>Інкрементує значення (тепер число дорівнює <code>1</code>)</li>
</ol>
<p><strong>Префіксний</strong> унарний оператор <code>++</code>:</p>
<ol type="1">
<li>Інкрементує значення (тепер число дорівнює <code>1</code>)</li>
<li>Повертає значення (<code>0</code>)</li>
</ol>
<p>Результат: <code>0 2 2</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-10">17. Що буде в консолі?</h6>
<div class="sourceCode" id="cb16"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">function</span> <span class="at">getPersonInfo</span>(one<span class="op">,</span> two<span class="op">,</span> three) <span class="op">{</span></a>
<a class="sourceLine" id="cb16-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(one)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(two)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-4" title="4">  <span class="va">console</span>.<span class="at">log</span>(three)<span class="op">;</span></a>
<a class="sourceLine" id="cb16-5" title="5"><span class="op">}</span></a>
<a class="sourceLine" id="cb16-6" title="6"></a>
<a class="sourceLine" id="cb16-7" title="7"><span class="kw">const</span> person <span class="op">=</span> <span class="st">&quot;Lydia&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb16-8" title="8"><span class="kw">const</span> age <span class="op">=</span> <span class="dv">21</span><span class="op">;</span></a>
<a class="sourceLine" id="cb16-9" title="9"></a>
<a class="sourceLine" id="cb16-10" title="10">getPersonInfo<span class="vs">`</span><span class="sc">${</span>person<span class="sc">}</span><span class="vs"> is </span><span class="sc">${</span>age<span class="sc">}</span><span class="vs"> years old`</span><span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>"Lydia"</code> <code>21</code> <code>["", " is ", " years old"]</code></li>
<li>B: <code>["", " is ", " years old"]</code> <code>"Lydia"</code> <code>21</code></li>
<li>C: <code>"Lydia"</code> <code>["", " is ", " years old"]</code> <code>21</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-b-2">Відповідь: B</h4>
<p>При використанні тегованих шаблонних литералов першим аргументом завжди буде масив строкових значень. Залишилися аргументами будуть значення переданих виразів!</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-11">18. Що буде в консолі?</h6>
<div class="sourceCode" id="cb17"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb17-1" title="1"><span class="kw">function</span> <span class="at">checkAge</span>(data) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-2" title="2">  <span class="cf">if</span> (data <span class="op">===</span> <span class="op">{</span> <span class="dt">age</span><span class="op">:</span> <span class="dv">18</span> <span class="op">}</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-3" title="3">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;You are an adult!&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-4" title="4">  <span class="op">}</span> <span class="cf">else</span> <span class="cf">if</span> (data <span class="op">==</span> <span class="op">{</span> <span class="dt">age</span><span class="op">:</span> <span class="dv">18</span> <span class="op">}</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb17-5" title="5">    <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;You are still an adult.&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-6" title="6">  <span class="op">}</span> <span class="cf">else</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb17-7" title="7">    <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`Hmm.. You don&#39;t have an age I guess`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb17-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb17-9" title="9"><span class="op">}</span></a>
<a class="sourceLine" id="cb17-10" title="10"></a>
<a class="sourceLine" id="cb17-11" title="11"><span class="at">checkAge</span>(<span class="op">{</span> <span class="dt">age</span><span class="op">:</span> <span class="dv">18</span> <span class="op">}</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>You are an adult!</code></li>
<li>B: <code>You are still an adult.</code></li>
<li>C: <code>Hmm.. You don't have an age I guess</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-4">Відповідь: C</h4>
<p>В операціях порівняння примітиви порівнюються за їх <em>значенням</em>, а об’єкти по <em>посиланнях</em>. JavaScript перевіряє, щоб об’єкти вказували на одну і ту ж область пам’яті.</p>
<p>Порівнянні об’єкти в нашому прикладі не такі: об’єкт, переданий як параметр, вказує на іншу область пам’яті, ніж об’єкти, що використовуються в порівняннях.</p>
<p>Тому <code>{age: 18} === {age: 18}</code> і <code>{age: 18} == {age: 18}</code> повертають <code>false</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-12">19. Що буде в консолі?</h6>
<div class="sourceCode" id="cb18"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">function</span> <span class="at">getAge</span>(...<span class="at">args</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb18-2" title="2">  <span class="va">console</span>.<span class="at">log</span>(<span class="kw">typeof</span> args)<span class="op">;</span></a>
<a class="sourceLine" id="cb18-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb18-4" title="4"></a>
<a class="sourceLine" id="cb18-5" title="5"><span class="at">getAge</span>(<span class="dv">21</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>"number"</code></li>
<li>B: <code>"array"</code></li>
<li>C: <code>"object"</code></li>
<li>D: <code>"NaN"</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-5">Відповідь: C</h4>
<p>Оператор поширення (<code>... args</code>) повертає масив з аргументами. Масив це об’єкт, тому <code>typeof args</code> повертає <code>"object"</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-13">20. Що буде в консолі?</h6>
<div class="sourceCode" id="cb19"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb19-1" title="1"><span class="kw">function</span> <span class="at">getAge</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb19-2" title="2">  <span class="st">&quot;use strict&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb19-3" title="3">  age <span class="op">=</span> <span class="dv">21</span><span class="op">;</span></a>
<a class="sourceLine" id="cb19-4" title="4">  <span class="va">console</span>.<span class="at">log</span>(age)<span class="op">;</span></a>
<a class="sourceLine" id="cb19-5" title="5"><span class="op">}</span></a>
<a class="sourceLine" id="cb19-6" title="6"></a>
<a class="sourceLine" id="cb19-7" title="7"><span class="at">getAge</span>()<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>21</code></li>
<li>B: <code>undefined</code></li>
<li>C: <code>ReferenceError</code></li>
<li>D: <code>TypeError</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-6">Відповідь: C</h4>
<p>Використовуючи <code>"use strict"</code>, можна бути впевненим, що ми помилково не оголосимо глобальні змінні. Ми раніше ніде не оголошували змінну <code>age</code>, тому з використанням <code>"use strict"</code> виникне ReferenceError. Без використання <code>"use strict"</code> помилки не виникне, а змінна <code>age</code> додасться в глобальний об’єкт.</p>
</p>
</details>
<hr />
<h6 id="чому-дорівнюватиме-sum">21. Чому дорівнюватиме sum?</h6>
<div class="sourceCode" id="cb20"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">const</span> sum <span class="op">=</span> <span class="at">eval</span>(<span class="st">&quot;10*10+5&quot;</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>105</code></li>
<li>B: <code>"105"</code></li>
<li>C: <code>TypeError</code></li>
<li>D: <code>"10*10+5"</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-7">Відповідь: A</h4>
<p><code>eval</code> виконує код, переданий у вигляді рядка. Якщо цей вислів (як в даному випадку), то обчислюється вираз. Вираз <code>10 * 10 + 5</code> поверне число <code>105</code>.</p>
</p>
</details>
<hr />
<h6 id="як-довго-буде-доступний-cool_secret">22. Як довго буде доступний cool_secret?</h6>
<div class="sourceCode" id="cb21"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb21-1" title="1"><span class="va">sessionStorage</span>.<span class="at">setItem</span>(<span class="st">&quot;cool_secret&quot;</span><span class="op">,</span> <span class="dv">123</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: Завжди, дані не загубляться.</li>
<li>B: Поки користувач не закриває вкладку.</li>
<li>C: Поки користувач не закриє браузер, а не тільки вкладку.</li>
<li>D: Поки користувач не вимикає комп’ютер.</li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-b-3">Відповідь: B</h4>
<p>Дані, збережені в <code>sessionStorage</code> очищаються після закриття <em>вкладки</em>.</p>
<p>При використанні <code>localStorage</code> дані зберігаються назавжди. Очистити їх можна, наприклад, використовуючи <code>localStorage.clear()</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-14">23. Що буде в консолі?</h6>
<div class="sourceCode" id="cb22"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb22-1" title="1"><span class="kw">var</span> num <span class="op">=</span> <span class="dv">8</span><span class="op">;</span></a>
<a class="sourceLine" id="cb22-2" title="2"><span class="kw">var</span> num <span class="op">=</span> <span class="dv">10</span><span class="op">;</span></a>
<a class="sourceLine" id="cb22-3" title="3"></a>
<a class="sourceLine" id="cb22-4" title="4"><span class="va">console</span>.<span class="at">log</span>(num)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>8</code></li>
<li>B: <code>10</code></li>
<li>C: <code>SyntaxError</code></li>
<li>D: <code>ReferenceError</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-b-4">Відповідь: B</h4>
<p>За допомогою ключового слова <code>var</code>, можна визначати скільки завгодно змінних з одним і тим же ім’ям. Змінна зберігатиме останнім присвоєне значення.</p>
<p>Ви не можете зробити це з <code>let</code> або<code>const</code>, оскільки вони блочні.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-15">24. Що буде в консолі?</h6>
<div class="sourceCode" id="cb23"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb23-1" title="1"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">{</span> <span class="dv">1</span><span class="op">:</span> <span class="st">&quot;a&quot;</span><span class="op">,</span> <span class="dv">2</span><span class="op">:</span> <span class="st">&quot;b&quot;</span><span class="op">,</span> <span class="dv">3</span><span class="op">:</span> <span class="st">&quot;c&quot;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb23-2" title="2"><span class="kw">const</span> set <span class="op">=</span> <span class="kw">new</span> <span class="at">Set</span>([<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span><span class="op">,</span> <span class="dv">4</span><span class="op">,</span> <span class="dv">5</span>])<span class="op">;</span></a>
<a class="sourceLine" id="cb23-3" title="3"></a>
<a class="sourceLine" id="cb23-4" title="4"><span class="va">obj</span>.<span class="at">hasOwnProperty</span>(<span class="st">&quot;1&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb23-5" title="5"><span class="va">obj</span>.<span class="at">hasOwnProperty</span>(<span class="dv">1</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb23-6" title="6"><span class="va">set</span>.<span class="at">has</span>(<span class="st">&quot;1&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb23-7" title="7"><span class="va">set</span>.<span class="at">has</span>(<span class="dv">1</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>false</code> <code>true</code> <code>false</code> <code>true</code></li>
<li>B: <code>false</code> <code>true</code> <code>true</code> <code>true</code></li>
<li>C: <code>true</code> <code>true</code> <code>false</code> <code>true</code></li>
<li>D: <code>true</code> <code>true</code> <code>true</code> <code>true</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-7">Відповідь: C</h4>
<p>Всі ключі об’єктів (крім <code>Symbols</code>) є рядками, навіть якщо задано не в вигляді рядків. Тому <code>obj.hasOwnProperty('1')</code> так само повертає <code>true</code>.</p>
<p>Але це не працює для <code>set</code>. Значення <code>"1"</code> немає в <code>set</code>: <code>set.has ('1')</code>, тому повертається <code>false</code>. Але <code>set.has(1)</code> поверне <code>true</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-16">25. Що буде в консолі?</h6>
<div class="sourceCode" id="cb24"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb24-1" title="1"><span class="kw">const</span> obj <span class="op">=</span> <span class="op">{</span> <span class="dt">a</span><span class="op">:</span> <span class="st">&quot;one&quot;</span><span class="op">,</span> <span class="dt">b</span><span class="op">:</span> <span class="st">&quot;two&quot;</span><span class="op">,</span> <span class="dt">a</span><span class="op">:</span> <span class="st">&quot;three&quot;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb24-2" title="2"><span class="va">console</span>.<span class="at">log</span>(obj)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>{ a: "one", b: "two" }</code></li>
<li>B: <code>{ b: "two", a: "three" }</code></li>
<li>C: <code>{ a: "three", b: "two" }</code></li>
<li>D: <code>SyntaxError</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-8">Відповідь: C</h4>
<p>Якщо є два ключі з однаковим ім’ям, то ключ буде перезаписан. Його позиція збережеться, але значенням буде встановлено останнім.</p>
</p>
</details>
<hr />
<h6 id="глобальний-контекст-виконання-створює-дві-речі-глобальний-обєкт-і-this">26. Глобальний контекст виконання створює дві речі: глобальний об’єкт і this</h6>
<ul>
<li>A: Так</li>
<li>B: Ні</li>
<li>C: В залежності від ситуації</li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-8">Відповідь: A</h4>
<p>Базовий контекст виконання це глобальний контекст виконання: це те, що є де завгодно в твоєму коді.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-17">27. Що буде в консолі?</h6>
<div class="sourceCode" id="cb25"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb25-1" title="1"><span class="cf">for</span> (<span class="kw">let</span> i <span class="op">=</span> <span class="dv">1</span><span class="op">;</span> i <span class="op">&lt;</span> <span class="dv">5</span><span class="op">;</span> i<span class="op">++</span>) <span class="op">{</span></a>
<a class="sourceLine" id="cb25-2" title="2">  <span class="cf">if</span> (i <span class="op">===</span> <span class="dv">3</span>) <span class="cf">continue</span><span class="op">;</span></a>
<a class="sourceLine" id="cb25-3" title="3">  <span class="va">console</span>.<span class="at">log</span>(i)<span class="op">;</span></a>
<a class="sourceLine" id="cb25-4" title="4"><span class="op">}</span></a></code></pre></div>
<ul>
<li>A: <code>1</code> <code>2</code></li>
<li>B: <code>1</code> <code>2</code> <code>3</code></li>
<li>C: <code>1</code> <code>2</code> <code>4</code></li>
<li>D: <code>1</code> <code>3</code> <code>4</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-9">Відповідь: C</h4>
<p>Оператор <code>continue</code> пропускає ітерацію, якщо умова повертає <code>true</code>.</p>
</p>
</details>
<hr />
<h6 id="яким-буде-результат-1">28. Яким буде результат?</h6>
<div class="sourceCode" id="cb26"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb26-1" title="1"><span class="va">String</span>.<span class="va">prototype</span>.<span class="at">giveLydiaPizza</span> <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb26-2" title="2">  <span class="cf">return</span> <span class="st">&quot;Just give Lydia pizza already!&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb26-3" title="3"><span class="op">};</span></a>
<a class="sourceLine" id="cb26-4" title="4"></a>
<a class="sourceLine" id="cb26-5" title="5"><span class="kw">const</span> name <span class="op">=</span> <span class="st">&quot;Lydia&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb26-6" title="6"></a>
<a class="sourceLine" id="cb26-7" title="7"><span class="va">name</span>.<span class="at">giveLydiaPizza</span>()<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>"Just give Lydia pizza already!"</code></li>
<li>B: <code>TypeError: not a function</code></li>
<li>C: <code>SyntaxError</code></li>
<li>D: <code>undefined</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-9">Відповідь: A</h4>
<p><code>String</code> це вбудований конструктор, до якого можна додавати властивості. Я додала метод до його прототипу. Рядки-примітиви автоматично конвертуються до рядків-об’єктів. Тому всі рядки (строкові об’єкти) мають доступ до цього методу!</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-18">29. Що буде в консолі?</h6>
<div class="sourceCode" id="cb27"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb27-1" title="1"><span class="kw">const</span> a <span class="op">=</span> <span class="op">{};</span></a>
<a class="sourceLine" id="cb27-2" title="2"><span class="kw">const</span> b <span class="op">=</span> <span class="op">{</span> <span class="dt">key</span><span class="op">:</span> <span class="st">&quot;b&quot;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb27-3" title="3"><span class="kw">const</span> c <span class="op">=</span> <span class="op">{</span> <span class="dt">key</span><span class="op">:</span> <span class="st">&quot;c&quot;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb27-4" title="4"></a>
<a class="sourceLine" id="cb27-5" title="5">a[b] <span class="op">=</span> <span class="dv">123</span><span class="op">;</span></a>
<a class="sourceLine" id="cb27-6" title="6">a[c] <span class="op">=</span> <span class="dv">456</span><span class="op">;</span></a>
<a class="sourceLine" id="cb27-7" title="7"></a>
<a class="sourceLine" id="cb27-8" title="8"><span class="va">console</span>.<span class="at">log</span>(a[b])<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>123</code></li>
<li>B: <code>456</code></li>
<li>C: <code>undefined</code></li>
<li>D: <code>ReferenceError</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-b-5">Відповідь: B</h4>
<p>Ключі об’єкта автоматично конвертуються в рядки. Ми збираємося додати об’єкт в якості ключа до об’єкта <code>a</code> зі значенням <code>123</code>.</p>
<p>Проте, коли ми наводимо об’єкт до рядка, він стає <code>"[object Object]"</code>. Таким чином, ми говоримо, що <code>a["object Object"] = 123</code>. Потім ми робимо те ж саме. <code>c</code> це інший об’єкт, який ми неявно наводимо до рядка. Тому <code>a["object Object"] = 456</code>.</p>
<p>Потім, коли ми виводимо <code>a[b]</code>, ми маємо на увазі <code>a["object Object"]</code>. Ми тільки що встановили туди значення <code>456</code>, тому в результаті отримуємо <code>456</code>.</p>
</p>
</details>
<hr />
<h6 id="яким-буде-результат-2">30. Яким буде результат?</h6>
<div class="sourceCode" id="cb28"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb28-1" title="1"><span class="kw">const</span> foo <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;First&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-2" title="2"><span class="kw">const</span> bar <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="at">setTimeout</span>(() <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Second&quot;</span>))<span class="op">;</span></a>
<a class="sourceLine" id="cb28-3" title="3"><span class="kw">const</span> baz <span class="op">=</span> () <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Third&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb28-4" title="4"></a>
<a class="sourceLine" id="cb28-5" title="5"><span class="at">bar</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb28-6" title="6"><span class="at">foo</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb28-7" title="7"><span class="at">baz</span>()<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>First</code> <code>Second</code> <code>Third</code></li>
<li>B: <code>First</code> <code>Third</code> <code>Second</code></li>
<li>C: <code>Second</code> <code>First</code> <code>Third</code></li>
<li>D: <code>Second</code> <code>Third</code> <code>First</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-b-6">Відповідь: B</h4>
<p>Ми викликаємо функцію <code>setTimeout</code> першої. Тим не менш, вона виводиться в консоль останньої</p>
<p>Це відбувається через те, що в браузерах у нас є не тільки рантайм движок, але і <code>WebAPI</code>. <code>WebAPI</code> надає нам функцію <code>setTimeout</code> і багато інших можливостей. Наприклад, DOM.</p>
<p>Після того як <em>коллбек</em> відправлений в <code>WebAPI</code>, функція <code>setTimeout</code> (але не коллбек!) виймається з стека.</p>
<p><img src="https://i.imgur.com/X5wsHOg.png" width="200"></p>
<p>Тепер викликається <code>foo</code>, і <code>"First"</code> виводиться в консоль.</p>
<p><img src="https://i.imgur.com/Pvc0dGq.png" width="200"></p>
<p><code>foo</code> дістається з стека, і викликається <code>baz</code>. <code>"Third"</code> виводиться в консоль.</p>
<p><img src="https://i.imgur.com/WhA2bCP.png" width="200"></p>
<p><code>WebAPI</code> не може додавати вміст в стек коли захоче. Замість цього він відправляє коллбек-функцію в так звану <em>чергу</em>.</p>
<p><img src="https://i.imgur.com/NSnDZmU.png" width="200"></p>
<p>Тут на сцену виходить цикл подій (event loop). <strong>Event loop</strong> перевіряє стек і черга завдань. Якщо стек порожній, то він бере перший елемент з черги і відправляє його в стек.</p>
<p><img src="https://i.imgur.com/uyiScAI.png" width="200"></p>
<p>Викликається <code>bar</code>, в консоль виводиться <code>"Second"</code> і ця функція дістається з стека.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-event.target-після-кліка-на-кнопку">31. Що буде в <code>event.target</code> після кліка на кнопку?</h6>
<div class="sourceCode" id="cb29"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb29-1" title="1"><span class="kw">&lt;div</span><span class="ot"> onclick=</span><span class="st">&quot;console.log(&#39;first div&#39;)&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb29-2" title="2">  <span class="kw">&lt;div</span><span class="ot"> onclick=</span><span class="st">&quot;console.log(&#39;second div&#39;)&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb29-3" title="3">    <span class="kw">&lt;button</span><span class="ot"> onclick=</span><span class="st">&quot;console.log(&#39;button&#39;)&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb29-4" title="4">      Click!</a>
<a class="sourceLine" id="cb29-5" title="5">    <span class="kw">&lt;/button&gt;</span></a>
<a class="sourceLine" id="cb29-6" title="6">  <span class="kw">&lt;/div&gt;</span></a>
<a class="sourceLine" id="cb29-7" title="7"><span class="kw">&lt;/div&gt;</span></a></code></pre></div>
<ul>
<li>A: Зовнішній <code>div</code></li>
<li>B: Внутрішній <code>div</code></li>
<li>C: <code>button</code></li>
<li>D: Масив з усіма вкладеними елементами</li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-10">Відповідь: C</h4>
<p>Метою події є <strong>найглибший</strong> вкладений елемент. Зупинити поширення подій можна за допомогою <code>event.stopPropagation</code></p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-після-кліка-по-параграфу">32. Що буде в консолі після кліка по параграфу?</h6>
<div class="sourceCode" id="cb30"><pre class="sourceCode html"><code class="sourceCode html"><a class="sourceLine" id="cb30-1" title="1"><span class="kw">&lt;div</span><span class="ot"> onclick=</span><span class="st">&quot;console.log(&#39;div&#39;)&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb30-2" title="2">  <span class="kw">&lt;p</span><span class="ot"> onclick=</span><span class="st">&quot;console.log(&#39;p&#39;)&quot;</span><span class="kw">&gt;</span></a>
<a class="sourceLine" id="cb30-3" title="3">    Click here!</a>
<a class="sourceLine" id="cb30-4" title="4">  <span class="kw">&lt;/p&gt;</span></a>
<a class="sourceLine" id="cb30-5" title="5"><span class="kw">&lt;/div&gt;</span></a></code></pre></div>
<ul>
<li>A: <code>p</code> <code>div</code></li>
<li>B: <code>div</code> <code>p</code></li>
<li>C: <code>p</code></li>
<li>D: <code>div</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-10">Відповідь: A</h4>
<p>Після кліка по <code>p</code> буде виведено <code>p</code> та <code>div</code>. У циклі життя події є три фази: <strong>захоплення</strong>, <strong>мета</strong> і <strong>спливання</strong>. За замовчуванням обробники подій виконуються на фазі спливання (якщо не встановлено параметр <code>useCapture</code> в <code>true</code>). Спливання йде з найглибшого елемента вгору.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-19">33. Що буде в консолі?</h6>
<div class="sourceCode" id="cb31"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb31-1" title="1"><span class="kw">const</span> person <span class="op">=</span> <span class="op">{</span> <span class="dt">name</span><span class="op">:</span> <span class="st">&quot;Lydia&quot;</span> <span class="op">};</span></a>
<a class="sourceLine" id="cb31-2" title="2"></a>
<a class="sourceLine" id="cb31-3" title="3"><span class="kw">function</span> <span class="at">sayHi</span>(age) <span class="op">{</span></a>
<a class="sourceLine" id="cb31-4" title="4">  <span class="va">console</span>.<span class="at">log</span>(<span class="vs">`</span><span class="sc">${</span><span class="kw">this</span>.<span class="at">name</span><span class="sc">}</span><span class="vs"> is </span><span class="sc">${</span>age<span class="sc">}</span><span class="vs">`</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-5" title="5"><span class="op">}</span></a>
<a class="sourceLine" id="cb31-6" title="6"></a>
<a class="sourceLine" id="cb31-7" title="7"><span class="va">sayHi</span>.<span class="at">call</span>(person<span class="op">,</span> <span class="dv">21</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb31-8" title="8"><span class="va">sayHi</span>.<span class="at">bind</span>(person<span class="op">,</span> <span class="dv">21</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>undefined is 21</code> <code>Lydia is 21</code></li>
<li>B: <code>function</code> <code>function</code></li>
<li>C: <code>Lydia is 21</code> <code>Lydia is 21</code></li>
<li>D: <code>Lydia is 21</code> <code>function</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-d-3">Відповідь: D</h4>
<p>В обох випадках ми передаємо об’єкт, на який буде вказувати <code>this</code>. Але <code>.call</code> виконується <em>відразу ж</em>!</p>
<p><code>.bind</code> повертає <em>копію</em> функції, але з прив’язаним контекстом. Вона не виконується негайно.</p>
</p>
</details>
<hr />
<h6 id="яким-буде-результат-3">34. Яким буде результат?</h6>
<div class="sourceCode" id="cb32"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb32-1" title="1"><span class="kw">function</span> <span class="at">sayHi</span>() <span class="op">{</span></a>
<a class="sourceLine" id="cb32-2" title="2">  <span class="cf">return</span> (() <span class="kw">=&gt;</span> <span class="dv">0</span>)()<span class="op">;</span></a>
<a class="sourceLine" id="cb32-3" title="3"><span class="op">}</span></a>
<a class="sourceLine" id="cb32-4" title="4"></a>
<a class="sourceLine" id="cb32-5" title="5"><span class="kw">typeof</span> <span class="at">sayHi</span>()<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>"object"</code></li>
<li>B: <code>"number"</code></li>
<li>C: <code>"function"</code></li>
<li>D: <code>"undefined"</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-b-7">Відповідь: B</h4>
<p>Функція <code>sayHi</code> повертає значення, що повертається з <em>негайно викликаного функціонального вираза</em> (IIFE). Результатом є <code>0</code> типу <code>"number"</code>.</p>
<p>Для інформації: в JS 7 вбудованих типів: <code>null</code>, <code>undefined</code>, <code>boolean</code>, <code>number</code>, <code>string</code>, <code>object</code>, <code>symbol</code>, та <code>bigint</code>. <code>"Function"</code> не є окремим типом, тому що функції є об’єктами типу <code>"object"</code>.</p>
</p>
</details>
<hr />
<h6 id="які-з-цих-значень-є-помилковими">35. Які з цих значень є “помилковими”?</h6>
<div class="sourceCode" id="cb33"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb33-1" title="1"><span class="dv">0</span><span class="op">;</span></a>
<a class="sourceLine" id="cb33-2" title="2"><span class="kw">new</span> <span class="at">Number</span>(<span class="dv">0</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb33-3" title="3">(<span class="st">&quot;&quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb33-4" title="4">(<span class="st">&quot; &quot;</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb33-5" title="5"><span class="kw">new</span> <span class="at">Boolean</span>(<span class="kw">false</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb33-6" title="6"><span class="kw">undefined</span><span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>0</code>, <code>''</code>, <code>undefined</code></li>
<li>B: <code>0</code>, <code>new Number(0)</code>, <code>''</code>, <code>new Boolean(false)</code>, <code>undefined</code></li>
<li>C: <code>0</code>, <code>''</code>, <code>new Boolean(false)</code>, <code>undefined</code></li>
<li>D: Всі значення.</li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-11">Відповідь: A</h4>
<p>Є тільки шість “помилкових” значень:</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>NaN</code></li>
<li><code>0</code></li>
<li><code>''</code> (порожній рядок)</li>
<li><code>false</code></li>
</ul>
<p>Конструктори функцій, такі як new <code>Number</code> та <code>new Boolean</code> є “істинними”.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-20">36. Що буде в консолі?</h6>
<div class="sourceCode" id="cb34"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb34-1" title="1"><span class="va">console</span>.<span class="at">log</span>(<span class="kw">typeof</span> <span class="kw">typeof</span> <span class="dv">1</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>"number"</code></li>
<li>B: <code>"string"</code></li>
<li>C: <code>"object"</code></li>
<li>D: <code>"undefined"</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-b-8">Відповідь: B</h4>
<p><code>typeof 1</code> повертає <code>"number"</code>. <code>typeof "number"</code> повертає <code>"string"</code></p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-21">37. Що буде в консолі?</h6>
<div class="sourceCode" id="cb35"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb35-1" title="1"><span class="kw">const</span> numbers <span class="op">=</span> [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]<span class="op">;</span></a>
<a class="sourceLine" id="cb35-2" title="2">numbers[<span class="dv">10</span>] <span class="op">=</span> <span class="dv">11</span><span class="op">;</span></a>
<a class="sourceLine" id="cb35-3" title="3"><span class="va">console</span>.<span class="at">log</span>(numbers)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>[1, 2, 3, 7 x null, 11]</code></li>
<li>B: <code>[1, 2, 3, 11]</code></li>
<li>C: <code>[1, 2, 3, 7 x empty, 11]</code></li>
<li>D: <code>SyntaxError</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-11">Відповідь: C</h4>
<p>Коли в масив додається значення, яке виходить за межі довжини масиву, JavaScript створює так звані “порожні клітинки”. Насправді вони мають значення <code>undefined</code>, але в консолі виводяться так:</p>
<p><code>[1, 2, 3, 7 x empty, 11]</code></p>
<p>в залежності від місця використання (може відрізнятися для браузерів, Node, і т.д.).</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-22">38. Що буде в консолі?</h6>
<div class="sourceCode" id="cb36"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb36-1" title="1">(() <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb36-2" title="2">  <span class="kw">let</span> x<span class="op">,</span> y<span class="op">;</span></a>
<a class="sourceLine" id="cb36-3" title="3">  <span class="cf">try</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb36-4" title="4">    <span class="cf">throw</span> <span class="kw">new</span> <span class="at">Error</span>()<span class="op">;</span></a>
<a class="sourceLine" id="cb36-5" title="5">  <span class="op">}</span> <span class="cf">catch</span> (x) <span class="op">{</span></a>
<a class="sourceLine" id="cb36-6" title="6">    (x <span class="op">=</span> <span class="dv">1</span>)<span class="op">,</span> (y <span class="op">=</span> <span class="dv">2</span>)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-7" title="7">    <span class="va">console</span>.<span class="at">log</span>(x)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-8" title="8">  <span class="op">}</span></a>
<a class="sourceLine" id="cb36-9" title="9">  <span class="va">console</span>.<span class="at">log</span>(x)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-10" title="10">  <span class="va">console</span>.<span class="at">log</span>(y)<span class="op">;</span></a>
<a class="sourceLine" id="cb36-11" title="11"><span class="op">}</span>)()<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>1</code> <code>undefined</code> <code>2</code></li>
<li>B: <code>undefined</code> <code>undefined</code> <code>undefined</code></li>
<li>C: <code>1</code> <code>1</code> <code>2</code></li>
<li>D: <code>1</code> <code>undefined</code> <code>undefined</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-12">Відповідь: A</h4>
<p>Блок <code>catch</code> отримує аргумент <code>x</code>. Це не той же <code>x</code>, який визначено в якості змінної перед рядком <code>try</code>.</p>
<p>Потім ми присвоюємо цього аргументу значення <code>1</code> та встановлюємо значення для змінної <code>y</code>. Потім виводимо в консоль значення аргументу <code>x</code>, що дорівнює <code>1</code>.</p>
<p>За межами блоку <code>catch</code> змінна <code>x</code> все ще <code>undefined</code>, а <code>y</code> дорівнює <code>2</code>. Коли ми викликаємо<code>console.log(x)</code> за межами блоку <code>catch</code>, цей виклик повертає <code>undefined</code>, а <code>y</code> повертає <code>2</code>.</p>
</p>
</details>
<hr />
<h6 id="все-в-javascript-це">39. Все в JavaScript це…</h6>
<ul>
<li>A: примітив або об’єкт</li>
<li>B: функція або об’єкт</li>
<li>C: питання з підступом! тільки об’єкти</li>
<li>D: число або об’єкт</li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-13">Відповідь: A</h4>
<p>В JavaScript є тільки примітиви і об’єкти.</p>
<p>Типи примітивів: <code>boolean</code>, <code>null</code>, <code>undefined</code>, <code>bigint</code>, <code>number</code>, <code>string</code>, та <code>symbol</code>.</p>
<p>Відмінністю примітиву від об’єкта є те, що примітиви не мають властивостей або методів. Проте, <code>'foo'.toUpperCase()</code> перетворюється в <code>'FOO'</code> та не викликає <code>TypeError</code>. Це відбувається тому, що при спробі отримання властивості або методу у примітиву (наприклад, рядки), JavaScript неявно оберне примітив об’єктом, використовуючи один з класів-обгорток (наприклад, <code>String</code>), а потім відразу ж знищить обгортку після обчислення виразу. Всі примітиви крім <code>null</code> та <code>undefined</code> поводяться таким чином.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-23">40. Що буде в консолі?</h6>
<div class="sourceCode" id="cb37"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb37-1" title="1">[[<span class="dv">0</span><span class="op">,</span> <span class="dv">1</span>]<span class="op">,</span> [<span class="dv">2</span><span class="op">,</span> <span class="dv">3</span>]].<span class="at">reduce</span>(</a>
<a class="sourceLine" id="cb37-2" title="2">  (acc<span class="op">,</span> cur) <span class="kw">=&gt;</span> <span class="op">{</span></a>
<a class="sourceLine" id="cb37-3" title="3">    <span class="cf">return</span> <span class="va">acc</span>.<span class="at">concat</span>(cur)<span class="op">;</span></a>
<a class="sourceLine" id="cb37-4" title="4">  <span class="op">},</span></a>
<a class="sourceLine" id="cb37-5" title="5">  [<span class="dv">1</span><span class="op">,</span> <span class="dv">2</span>]</a>
<a class="sourceLine" id="cb37-6" title="6">)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>[0, 1, 2, 3, 1, 2]</code></li>
<li>B: <code>[6, 1, 2]</code></li>
<li>C: <code>[1, 2, 0, 1, 2, 3]</code></li>
<li>D: <code>[1, 2, 6]</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-c-12">Відповідь: C</h4>
<p><code>[1, 2]</code> - початкове значення, з яким инициализируется змінна <code>acc</code>. Після першого проходу <code>acc</code> дорівнюватиме <code>[1,2]</code>, а <code>cur</code> буде <code>[0,1]</code>. Після конкатенації результат буде <code>[1, 2, 0, 1]</code>.</p>
<p>Потім <code>acc</code> дорівнює <code>[1, 2, 0, 1]</code>, а cur <code>[2, 3]</code>. Після злиття отримаємо <code>[1, 2, 0, 1, 2, 3]</code>.</p>
</p>
</details>
<hr />
<h6 id="що-буде-в-консолі-24">41. Що буде в консолі?</h6>
<div class="sourceCode" id="cb38"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb38-1" title="1"><span class="op">!!</span><span class="kw">null</span><span class="op">;</span></a>
<a class="sourceLine" id="cb38-2" title="2"><span class="op">!!</span><span class="st">&quot;&quot;</span><span class="op">;</span></a>
<a class="sourceLine" id="cb38-3" title="3"><span class="op">!!</span><span class="dv">1</span><span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>false</code> <code>true</code> <code>false</code></li>
<li>B: <code>false</code> <code>false</code> <code>true</code></li>
<li>C: <code>false</code> <code>true</code> <code>true</code></li>
<li>D: <code>true</code> <code>true</code> <code>false</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-b-9">Відповідь: B</h4>
<p><code>null</code> “НЕправдивий”. <code>!null</code> повертає <code>true</code>. <code>!true</code> повертає <code>false</code>.</p>
<p><code>""</code> “НЕправдивий”. <code>!""</code> повертає <code>true</code>. <code>!true</code> повертає <code>false</code>.</p>
<p><code>1</code> “правдивий”. <code>!1</code> повертає <code>false</code>. <code>!false</code> повертає <code>true</code>.</p>
</p>
</details>
<hr />
<h6 id="що-повертає-метод-setinterval">42. Що повертає метод <code>setInterval</code>?</h6>
<div class="sourceCode" id="cb39"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb39-1" title="1"><span class="at">setInterval</span>(() <span class="kw">=&gt;</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&quot;Hi&quot;</span>)<span class="op">,</span> <span class="dv">1000</span>)<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: унікальний id</li>
<li>B: вказану кількість мілісекунд</li>
<li>C: передану функцію</li>
<li>D: <code>undefined</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-14">Відповідь: A</h4>
<p>Це метод повертає унікальний id. Цей id може бути використаний для очищення інтервалу за допомогою функції <code>clearInterval()</code>.</p>
</p>
</details>
<hr />
<h6 id="what-does-this-return">43. What does this return?</h6>
<div class="sourceCode" id="cb40"><pre class="sourceCode javascript"><code class="sourceCode javascript"><a class="sourceLine" id="cb40-1" title="1">[...<span class="st">&quot;Lydia&quot;</span>]<span class="op">;</span></a></code></pre></div>
<ul>
<li>A: <code>["L", "y", "d", "i", "a"]</code></li>
<li>B: <code>["Lydia"]</code></li>
<li>C: <code>[[], "Lydia"]</code></li>
<li>D: <code>[["L", "y", "d", "i", "a"]]</code></li>
</ul>
<details>
<summary><b>Відповідь</b></summary>
<p>
<h4 id="відповідь-a-15">Відповідь: A</h4>
<p>Рядок є ітеріруемой сутністю. Оператор поширення перетворює кожен символ в окремий елемент.</p>
</p>
</details>
</body>
</html>
