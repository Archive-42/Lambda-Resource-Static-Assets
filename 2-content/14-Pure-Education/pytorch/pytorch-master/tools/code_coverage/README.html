<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>README</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(title);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
</head>
<body>
<h1 id="code-coverage-tool-for-pytorch">Code Coverage Tool for Pytorch</h1>
<h2 id="overview">Overview</h2>
<p>This tool is designed for calculating code coverage for Pytorch project. It’s an integrated tool. You can use this tool to run and generate both file-level and line-level report for C++ and Python tests. It will also be the tool we use in <em>CircleCI</em> to generate report for each master commit.</p>
<h3 id="simple">Simple</h3>
<ul>
<li><em>Simple command to run:</em>
<ul>
<li><code>python oss_coverage.py</code></li>
</ul></li>
<li><em>Argument <code>--clean</code> will do all the messy clean up things for you</em></li>
</ul>
<h3 id="but-powerful">But Powerful</h3>
<ul>
<li><em>Choose your own interested folder</em>:
<ul>
<li>Default folder will be good enough in most times</li>
<li>Flexible: you can specify one or more folder(s) that you are interested in</li>
</ul></li>
<li><em>Run only the test you want:</em>
<ul>
<li>By default it will run all the c++ and python tests</li>
<li>Flexible: you can specify one or more test(s) that you want to run</li>
</ul></li>
<li><em>Final report:</em>
<ul>
<li>File-Level: The coverage percentage for each file you are interested in</li>
<li>Line-Level: The coverage details for each line in each file you are interested in</li>
<li>Html-Report (only for <code>gcc</code>): The beautiful HTML report supported by <code>lcov</code>, combine file-level report and line-lever report into a graphical view.</li>
</ul></li>
<li><em>More complex but flexible options:</em>
<ul>
<li>Use different stages like <em>–run, –export, –summary</em> to achieve more flexible functionality</li>
</ul></li>
</ul>
<h2 id="how-to-use">How to use</h2>
<p>This part will introduce about the arguments you can use when run this tool. The arguments are powerful, giving you full flexibility to do different work. We have two different compilers, <code>gcc</code> and <code>clang</code>, and this tool supports both. But it is recommended to use <code>gcc</code> because it’s much faster and use less disk place. The examples will also be divided to two parts, for <code>gcc</code> and <code>clang</code>.</p>
<h2 id="preparation">Preparation</h2>
<p>The first step is to <a href="https://github.com/pytorch/pytorch#from-source">build <em>Pytorch</em> from source</a> with <code>CODE_COVERAGE</code> option <code>ON</code>. You may also want to set <code>BUILD_TEST</code> option <code>ON</code> to get the test binaries. Besides, if you are under <code>gcc</code> compiler, to get accurate result, it is recommended to also select <code>CMAKE_BUILD_CONFIG=Debug</code>. See: <a href="https://github.com/pytorch/pytorch#adjust-build-options-optional">how to adjust build options</a> for reference. Following is one way to adjust build option:</p>
<pre><code># in build/ folder (all build artifacts must in `build/` folder)
cmake .. -DCODE_COVERAGE=ON -DBUILD_TEST=ON -DCMAKE_BUILD_CONFIG=Debug</code></pre>
<h2 id="examples">Examples</h2>
<p>The tool will auto-detect compiler type in your operating system, but if you are using another one, you need to specify it. Besides, if you are using <code>clang</code>, <code>llvm</code> tools are required. So the first step is to set some environment value if needed:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb2-1" title="1"><span class="co"># set compiler type, the default is auto detected, you can check it at the start of log.txt</span></a>
<a class="sourceLine" id="cb2-2" title="2"><span class="bu">export</span> <span class="va">COMPILER_TYPE=</span><span class="st">&quot;CLANG&quot;</span></a>
<a class="sourceLine" id="cb2-3" title="3"><span class="co"># set llvm path for clang, by default is /usr/local/opt/llvm/bin</span></a>
<a class="sourceLine" id="cb2-4" title="4"><span class="bu">export</span> <span class="va">LLVM_TOOL_PATH=</span>...</a></code></pre></div>
<p>Great, you are ready to run the code coverage tool for the first time! Start from the simple command:</p>
<pre><code>python oss_coverage.py --run-only=atest</code></pre>
<p>This command will run <code>atest</code> binary in <code>build/bin/</code> folder and generate reoports over the entire <em>Pytorch</em> folder. You can find the reports in <code>profile/summary</code>. But you may only be interested in the <code>aten</code> folder, in this case, try:</p>
<pre><code>python oss_coverage.py --run-only=atest --interested-only=aten</code></pre>
<p>In <em>Pytorch</em>, <code>c++</code> tests located in <code>build/bin/</code> and <code>python</code> tests located in <code>test/</code>. If you want to run <code>python</code> test, try:</p>
<pre><code>python oss_coverage.py --run-only=test_complex.py</code></pre>
<p>You may also want to specify more than one test or interested folder, in this case, try:</p>
<pre><code>python oss_coverage.py --run-only=atest c10_logging_test --interested-only aten/src/Aten c10/core</code></pre>
<p>That it is! With these two simple options, you can customize many different functionality according to your need. By default, the tool will run all tests in <code>build/bin</code> folder (by running all executable binaries in it) and <code>test/</code> folder (by running <code>run_test.py</code>), and then collect coverage over the entire <em>Pytorch</em> folder. If this is what you want, try: <em>(Note: It’s not recommended to run default all tests in clang, because it will take too much space)</em></p>
<div class="sourceCode" id="cb7"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb7-1" title="1"><span class="ex">python</span> oss_coverage.py</a></code></pre></div>
<h3 id="for-more-complex-arguments-and-functionalities">For more complex arguments and functionalities</h3>
<h4 id="gcc">GCC</h4>
<p>The code coverage with <code>gcc</code> compiler can be divided into 3 step: 1. run the tests: <code>--run</code> 2. run <code>gcov</code> to get json report: <code>--export</code> 3. summarize it to human readable file report and line report: <code>--summary</code></p>
<p>By default all steps will be run, but you can specify only run one of them. Following is some usage scenario:</p>
<p><strong>1. Interested in different folder</strong> <code>—summary</code> is useful when you have different interested folder. For example,</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode bash"><code class="sourceCode bash"><a class="sourceLine" id="cb8-1" title="1"><span class="co"># after run this command</span></a>
<a class="sourceLine" id="cb8-2" title="2"><span class="ex">python</span> oss_coverage.py --run-only=atest --interested-folder=aten</a>
<a class="sourceLine" id="cb8-3" title="3"><span class="co"># you may then want to learn atest&#39;s coverage over c10, instead of running the test again, you can:</span></a>
<a class="sourceLine" id="cb8-4" title="4"><span class="ex">python</span> oss_coverage.py --run-only=atest --interested-folder=c10 --summary</a></code></pre></div>
<p><strong>2. Run tests yourself</strong> When you are developing a new feature, you may first run the tests yourself to make sure the implementation is all right and then want to learn its coverage. But sometimes the test take very long time and you don’t want to wait to run it again when doing code coverage. In this case, you can use these arguments to accerate your development (make sure you build pytorch with the coverage option!):</p>
<pre><code># run tests when you are devloping a new feature, assume the the test is `test_nn.py`
python oss_coverage.py --run-only=test_nn.py
# or you can run it yourself
cd test/ &amp;&amp; python test_nn.py
# then you want to learn about code coverage, you can just run:
python oss_coverage.py --run-only=test_nn.py --export --summary</code></pre>
<h3 id="clang">CLANG</h3>
<p>The steps for <code>clang</code> is very similar to <code>gcc</code>, but the export stage is divided into two step: 1. run the tests: <code>--run</code> 2. run <code>gcov</code> to get json report: <code>--merge</code> <code>--export</code> 3. summarize it to human readable file report and line report: <code>--summary</code></p>
<p>Therefore, just replace <code>--export</code> in <code>gcc</code> examples with <code>--merge</code> and <code>--export</code>, you will find it work!</p>
<h2 id="reference">Reference</h2>
<p>For <code>gcc</code> * See about how to invoke <code>gcov</code>, read <a href="https://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html#Invoking-Gcov">Invoking gcov</a> will be helpful</p>
<p>For <code>clang</code> * If you are not familiar with the procedure of generating code coverage report by using <code>clang</code>, read <a href="https://clang.llvm.org/docs/SourceBasedCodeCoverage.html">Source-based Code Coverage</a> will be helpful.</p>
</body>
</html>
